<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>WizualizacjaAlgorytmow.NodZ.Main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>WizualizacjaAlgorytmow.NodZ.Main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import re
import json

from PyQt5 import QtGui, QtCore, QtWidgets
from Paths import Paths
import NodZ.Utils as utils



defaultConfigPath = Paths.nodz_config()


class Nodz(QtWidgets.QGraphicsView):

    &#34;&#34;&#34;
    The main view for the node graph representation.

    The node view implements a state pattern to control all the
    different user interactions.

    &#34;&#34;&#34;

    pyqtSignal_NodeCreated = QtCore.pyqtSignal(object)
    pyqtSignal_NodeDeleted = QtCore.pyqtSignal(object)
    pyqtSignal_NodeEdited = QtCore.pyqtSignal(object, object)
    pyqtSignal_NodeSelected = QtCore.pyqtSignal(object)
    pyqtSignal_NodeMoved = QtCore.pyqtSignal(str, object)
    pyqtSignal_NodeDoubleClicked = QtCore.pyqtSignal(str)

    pyqtSignal_AttrCreated = QtCore.pyqtSignal(object, object)
    pyqtSignal_AttrDeleted = QtCore.pyqtSignal(object, object)
    pyqtSignal_AttrEdited = QtCore.pyqtSignal(object, object, object)

    pyqtSignal_PlugConnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_PlugDisconnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_SocketConnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_SocketDisconnected = QtCore.pyqtSignal(object, object, object, object)

    pyqtSignal_GraphSaved = QtCore.pyqtSignal()
    pyqtSignal_GraphLoaded = QtCore.pyqtSignal()
    pyqtSignal_GraphCleared = QtCore.pyqtSignal()
    pyqtSignal_GraphEvaluated = QtCore.pyqtSignal()

    pyqtSignal_KeyPressed = QtCore.pyqtSignal(object)
    pyqtSignal_Dropped = QtCore.pyqtSignal()

    def __init__(self, parent, configPath=defaultConfigPath):
        &#34;&#34;&#34;
        Initialize the graphics view.

        &#34;&#34;&#34;
        super(Nodz, self).__init__(parent)

        # Load nodz configuration.
        self.loadConfig(configPath)

        # General data.
        self.gridVisToggle = True
        self.gridSnapToggle = False
        self._nodeSnap = False
        self.selectedNodes = []

        # Connections data.
        self.drawingConnection = False
        self.currentHoveredNode = None
        self.sourcepyqtSlot = None

        # Display options.
        self.currentState = &#39;DEFAULT&#39;
        self.pressedKeys = list()

    def wheelEvent(self, event):
        &#34;&#34;&#34;
        Zoom in the view with the mouse wheel.

        &#34;&#34;&#34;
        self.currentState = &#39;ZOOM_VIEW&#39;
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        inFactor = 1.15
        outFactor = 1 / inFactor

        if event.angleDelta().y() &gt; 0:
            zoomFactor = inFactor
        else:
            zoomFactor = outFactor

        self.scale(zoomFactor, zoomFactor)
        self.currentState = &#39;DEFAULT&#39;

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Initialize tablet zoom, drag canvas and the selection.

        &#34;&#34;&#34;
        # Tablet zoom
        if (event.button() == QtCore.Qt.RightButton and
            event.modifiers() == QtCore.Qt.AltModifier):
            self.currentState = &#39;ZOOM_VIEW&#39;
            self.initMousePos = event.pos()
            self.zoomInitialPos = event.pos()
            self.initMouse = QtGui.QCursor.pos()
            self.setInteractive(False)


        # Drag view
        elif (event.button() == QtCore.Qt.MiddleButton and
              event.modifiers() == QtCore.Qt.AltModifier):
            self.currentState = &#39;DRAG_VIEW&#39;
            self.prevPos = event.pos()
            self.setCursor(QtCore.Qt.ClosedHandCursor)
            self.setInteractive(False)


        # Rubber band selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.NoModifier and
              self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is None):
            self.currentState = &#39;SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Drag Item
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.NoModifier and
              self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is not None):
            self.currentState = &#39;DRAG_ITEM&#39;
            self.setInteractive(True)


        # Add selection
        elif (event.button() == QtCore.Qt.LeftButton and
              QtCore.Qt.Key_Shift in self.pressedKeys and
              QtCore.Qt.Key_Control in self.pressedKeys):
            self.currentState = &#39;ADD_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Subtract selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.ControlModifier):
            self.currentState = &#39;SUBTRACT_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Toggle selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.ShiftModifier):
            self.currentState = &#39;TOGGLE_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        else:
            self.currentState = &#39;DEFAULT&#39;

        super(Nodz, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Update tablet zoom, canvas dragging and selection.

        &#34;&#34;&#34;
        # Zoom.
        if self.currentState == &#39;ZOOM_VIEW&#39;:
            offset = self.zoomInitialPos.x() - event.pos().x()

            if offset &gt; self.previousMouseOffset:
                self.previousMouseOffset = offset
                self.zoomDirection = -1
                self.zoomIncr -= 1

            elif offset == self.previousMouseOffset:
                self.previousMouseOffset = offset
                if self.zoomDirection == -1:
                    self.zoomDirection = -1
                else:
                    self.zoomDirection = 1

            else:
                self.previousMouseOffset = offset
                self.zoomDirection = 1
                self.zoomIncr += 1

            if self.zoomDirection == 1:
                zoomFactor = 1.03
            else:
                zoomFactor = 1 / 1.03

            # Perform zoom and re-center on initial click position.
            pBefore = self.mapToScene(self.initMousePos)
            self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorViewCenter)
            self.scale(zoomFactor, zoomFactor)
            pAfter = self.mapToScene(self.initMousePos)
            diff = pAfter - pBefore

            self.setTransformationAnchor(QtWidgets.QGraphicsView.NoAnchor)
            self.translate(diff.x(), diff.y())
            pass

        # Drag canvas.
        elif self.currentState == &#39;DRAG_VIEW&#39;:
            offset = self.prevPos - event.pos()
            self.prevPos = event.pos()
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() + offset.y())
            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() + offset.x())

        # RuberBand selection.
        elif (self.currentState == &#39;SELECTION&#39; or
              self.currentState == &#39;ADD_SELECTION&#39; or
              self.currentState == &#39;SUBTRACT_SELECTION&#39; or
              self.currentState == &#39;TOGGLE_SELECTION&#39;):
            self.rubberband.setGeometry(QtCore.QRect(self.origin, event.pos()).normalized())

        super(Nodz, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Apply tablet zoom, dragging and selection.

        &#34;&#34;&#34;
        # Zoom the View.
        if self.currentState == &#39;.ZOOM_VIEW&#39;:
            self.offset = 0
            self.zoomDirection = 0
            self.zoomIncr = 0
            self.setInteractive(True)


        # Drag View.
        elif self.currentState == &#39;DRAG_VIEW&#39;:
            self.setCursor(QtCore.Qt.ArrowCursor)
            self.setInteractive(True)


        # Selection.
        elif self.currentState == &#39;SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            self.scene().setSelectionArea(painterPath)


        # Add Selection.
        elif self.currentState == &#39;ADD_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                item.setSelected(True)


        # Subtract Selection.
        elif self.currentState == &#39;SUBTRACT_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                item.setSelected(False)


        # Toggle Selection
        elif self.currentState == &#39;TOGGLE_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                if item.isSelected():
                    item.setSelected(False)
                else:
                    item.setSelected(True)

        self.currentState = &#39;DEFAULT&#39;

        super(Nodz, self).mouseReleaseEvent(event)

    def keyPressEvent(self, event):
        &#34;&#34;&#34;
        Save pressed key and apply shortcuts.

        Shortcuts are:
        DEL - Delete the selected nodes
        F - Focus view on the selection

        &#34;&#34;&#34;
        if event.key() not in self.pressedKeys:
            self.pressedKeys.append(event.key())

        if event.key() in (QtCore.Qt.Key_Delete, QtCore.Qt.Key_Backspace):
            self._deleteSelectedNodes()

        if event.key() == QtCore.Qt.Key_F:
            self._focus()

        if event.key() == QtCore.Qt.Key_S:
            self._nodeSnap = True

        # Emit pyqtSignal.
        self.pyqtSignal_KeyPressed.emit(event.key())

    def keyReleaseEvent(self, event):
        &#34;&#34;&#34;
        Clear the key from the pressed key list.

        &#34;&#34;&#34;
        if event.key() == QtCore.Qt.Key_S:
            self._nodeSnap = False

        if event.key() in self.pressedKeys:
            self.pressedKeys.remove(event.key())

    def _initRubberband(self, position):
        &#34;&#34;&#34;
        Initialize the rubber band at the given position.

        &#34;&#34;&#34;
        self.rubberBandStart = position
        self.origin = position
        self.rubberband.setGeometry(QtCore.QRect(self.origin, QtCore.QSize()))
        self.rubberband.show()

    def _releaseRubberband(self):
        &#34;&#34;&#34;
        Hide the rubber band and return the path.

        &#34;&#34;&#34;
        painterPath = QtGui.QPainterPath()
        rect = self.mapToScene(self.rubberband.geometry())
        painterPath.addPolygon(rect)
        self.rubberband.hide()
        return painterPath

    def _focus(self):
        &#34;&#34;&#34;
        Center on selected nodes or all of them if no active selection.

        &#34;&#34;&#34;
        if self.scene().selectedItems():
            itemsArea = self._getSelectionBoundingbox()
            self.fitInView(itemsArea, QtCore.Qt.KeepAspectRatio)
        else:
            itemsArea = self.scene().itemsBoundingRect()
            self.fitInView(itemsArea, QtCore.Qt.KeepAspectRatio)

    def _getSelectionBoundingbox(self):
        &#34;&#34;&#34;
        Return the bounding box of the selection.

        &#34;&#34;&#34;
        bbx_min = None
        bbx_max = None
        bby_min = None
        bby_max = None
        bbw = 0
        bbh = 0
        for item in self.scene().selectedItems():
            pos = item.scenePos()
            x = pos.x()
            y = pos.y()
            w = x + item.boundingRect().width()
            h = y + item.boundingRect().height()

            # bbx min
            if bbx_min is None:
                bbx_min = x
            elif x &lt; bbx_min:
                bbx_min = x
            # end if

            # bbx max
            if bbx_max is None:
                bbx_max = w
            elif w &gt; bbx_max:
                bbx_max = w
            # end if

            # bby min
            if bby_min is None:
                bby_min = y
            elif y &lt; bby_min:
                bby_min = y
            # end if

            # bby max
            if bby_max is None:
                bby_max = h
            elif h &gt; bby_max:
                bby_max = h
            # end if
        # end if
        bbw = bbx_max - bbx_min
        bbh = bby_max - bby_min
        return QtCore.QRectF(QtCore.QRect(bbx_min, bby_min, bbw, bbh))

    def _deleteSelectedNodes(self):
        &#34;&#34;&#34;
        Delete selected nodes.

        &#34;&#34;&#34;
        selected_nodes = list()
        for node in self.scene().selectedItems():
            selected_nodes.append(node.name)
            node._remove()

        # Emit pyqtSignal.
        self.pyqtSignal_NodeDeleted.emit(selected_nodes)

    def _returnSelection(self):
        &#34;&#34;&#34;
        Wrapper to return selected items.

        &#34;&#34;&#34;
        selected_nodes = list()
        if self.scene().selectedItems():
            for node in self.scene().selectedItems():
                selected_nodes.append(node.name)

        # Emit pyqtSignal.
        self.pyqtSignal_NodeSelected.emit(selected_nodes)


    ##################################################################
    # API
    ##################################################################

    def loadConfig(self, filePath):
        &#34;&#34;&#34;
        Set a specific configuration for this instance of Nodz.

        :type  filePath: str.
        :param filePath: The path to the config file that you want to
                         use.

        &#34;&#34;&#34;
        self.config = utils._loadConfig(filePath)

    def initialize(self):
        &#34;&#34;&#34;
        Setup the view&#39;s behavior.

        &#34;&#34;&#34;
        # Setup view.
        config = self.config
        self.setRenderHint(QtGui.QPainter.Antialiasing, config[&#39;antialiasing&#39;])
        self.setRenderHint(QtGui.QPainter.TextAntialiasing, config[&#39;antialiasing&#39;])
        self.setRenderHint(QtGui.QPainter.HighQualityAntialiasing, config[&#39;antialiasing_boost&#39;])
        self.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, config[&#39;smooth_pixmap&#39;])
        self.setRenderHint(QtGui.QPainter.NonCosmeticDefaultPen, True)
        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.rubberband = QtWidgets.QRubberBand(QtWidgets.QRubberBand.Rectangle, self)

        # Setup scene.
        scene = NodeScene(self)
        sceneWidth = config[&#39;scene_width&#39;]
        sceneHeight = config[&#39;scene_height&#39;]
        scene.setSceneRect(0, 0, sceneWidth, sceneHeight)
        self.setScene(scene)
        # Connect scene node moved pyqtSignal
        scene.pyqtSignal_NodeMoved.connect(self.pyqtSignal_NodeMoved)

        # Tablet zoom.
        self.previousMouseOffset = 0
        self.zoomDirection = 0
        self.zoomIncr = 0

        # Connect pyqtSignals.
        self.scene().selectionChanged.connect(self._returnSelection)


    # NODES
    def createNode(self, name=&#39;default&#39;, preset=&#39;node_default&#39;, position=None, alternate=True):
        &#34;&#34;&#34;
        Create a new node with a given name, position and color.

        :type  name: str.
        :param name: The name of the node. The name has to be unique
                     as it is used as a key to store the node object.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  position: QtCore.QPoint.
        :param position: The position of the node once created. If None,
                         it will be created at the center of the scene.

        :type  alternate: bool.
        :param alternate: The attribute color alternate state, if True,
                          every 2 attribute the color will be slightly
                          darker.

        :return : The created node

        &#34;&#34;&#34;
        # Check for name clashes
        if name in self.scene().nodes.keys():
            print(&#39;A node with the same name already exists : {0}&#39;.format(name))
            print(&#39;Node creation aborted !&#39;)
            return
        else:
            nodeItem = NodeItem(name=name, alternate=alternate, preset=preset,
                                config=self.config)

            # Store node in scene.
            self.scene().nodes[name] = nodeItem

            if not position:
                # Get the center of the view.
                position = self.mapToScene(self.viewport().rect().center())

            # Set node position.
            self.scene().addItem(nodeItem)
            nodeItem.setPos(position - nodeItem.nodeCenter)

            # Emit pyqtSignal.
            self.pyqtSignal_NodeCreated.emit(name)

            return nodeItem

    def deleteNode(self, node):
        &#34;&#34;&#34;
        Delete the specified node from the view.

        :type  node: class.
        :param node: The node instance that you want to delete.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Node deletion aborted !&#39;)
            return

        if node in self.scene().nodes.values():
            nodeName = node.name
            node._remove()

            # Emit pyqtSignal.
            self.pyqtSignal_NodeDeleted.emit([nodeName])

    def editNode(self, node, newName=None):
        &#34;&#34;&#34;
        Rename an existing node.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  newName: str.
        :param newName: The new name for the given node.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Node edition aborted !&#39;)
            return

        oldName = node.name

        if newName != None:
            # Check for name clashes
            if newName in self.scene().nodes.keys():
                print(&#39;A node with the same name already exists : {0}&#39;.format(newName))
                print(&#39;Node edition aborted !&#39;)
                return
            else:
                node.name = newName

        # Replace node data.
        self.scene().nodes[newName] = self.scene().nodes[oldName]
        self.scene().nodes.pop(oldName)

        # Store new node name in the connections
        if node.sockets:
            for socket in node.sockets.values():
                for connection in socket.connections:
                    connection.socketNode = newName

        if node.plugs:
            for plug in node.plugs.values():
                for connection in plug.connections:
                    connection.plugNode = newName

        node.update()

        # Emit pyqtSignal.
        self.pyqtSignal_NodeEdited.emit(oldName, newName)


    # ATTRS
    def createAttribute(self, node, name=&#39;default&#39;, index=-1, preset=&#39;attr_default&#39;, plug=True, socket=True, dataType=None, plugMaxConnections=-1, socketMaxConnections=1):
        &#34;&#34;&#34;
        Create a new attribute with a given name.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  name: str.
        :param name: The name of the attribute. The name has to be
                     unique as it is used as a key to store the node
                     object.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  plug: bool.
        :param plug: Whether or not this attribute can emit connections.

        :type  socket: bool.
        :param socket: Whether or not this attribute can receive
                       connections.

        :type  dataType: type.
        :param dataType: Type of the data represented by this attribute
                         in order to highlight attributes of the same
                         type while performing a connection.

        :type  plugMaxConnections: int.
        :param plugMaxConnections: The maximum connections that the plug can have (-1 for infinite).

        :type  socketMaxConnections: int.
        :param socketMaxConnections: The maximum connections that the socket can have (-1 for infinite).

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute creation aborted !&#39;)
            return

        if name in node.attrs:
            print(&#39;An attribute with the same name already exists : {0}&#39;.format(name))
            print(&#39;Attribute creation aborted !&#39;)
            return

        node._createAttribute(name=name, index=index, preset=preset, plug=plug, socket=socket, dataType=dataType, plugMaxConnections=plugMaxConnections, socketMaxConnections=socketMaxConnections)

        # Emit pyqtSignal.
        self.pyqtSignal_AttrCreated.emit(node.name, index)

    def deleteAttribute(self, node, index):
        &#34;&#34;&#34;
        Delete the specified attribute.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  index: int.
        :param index: The index of the attribute in the node.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute deletion aborted !&#39;)
            return

        node._deleteAttribute(index)

        # Emit pyqtSignal.
        self.pyqtSignal_AttrDeleted.emit(node.name, index)

    def editAttribute(self, node, index, newName=None, newIndex=None):
        &#34;&#34;&#34;
        Edit the specified attribute.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  newName: str.
        :param newName: The new name for the given attribute.

        :type  newIndex: int.
        :param newIndex: The index for the given attribute.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute creation aborted !&#39;)
            return

        if newName != None:
            if newName in node.attrs:
                print(&#39;An attribute with the same name already exists : {0}&#39;.format(newName))
                print(&#39;Attribute edition aborted !&#39;)
                return
            else:
                oldName = node.attrs[index]

            # Rename in the pyqtSlot item(s).
            if node.attrsData[oldName][&#39;plug&#39;]:
                node.plugs[oldName].attribute = newName
                node.plugs[newName] = node.plugs[oldName]
                node.plugs.pop(oldName)
                for connection in node.plugs[newName].connections:
                    connection.plugAttr = newName

            if node.attrsData[oldName][&#39;socket&#39;]:
                node.sockets[oldName].attribute = newName
                node.sockets[newName] = node.sockets[oldName]
                node.sockets.pop(oldName)
                for connection in node.sockets[newName].connections:
                    connection.socketAttr = newName

            # Replace attribute data.
            node.attrsData[oldName][&#39;name&#39;] = newName
            node.attrsData[newName] = node.attrsData[oldName]
            node.attrsData.pop(oldName)
            node.attrs[index] = newName

        if isinstance(newIndex, int):
            attrName = node.attrs[index]

            utils._swapListIndices(node.attrs, index, newIndex)

            # Refresh connections.
            for plug in node.plugs.values():
                plug.update()
                if plug.connections:
                    for connection in plug.connections:
                        if isinstance(connection.source, PlugItem):
                            connection.source = plug
                            connection.source_point = plug.center()
                        else:
                            connection.target = plug
                            connection.target_point = plug.center()
                        if newName:
                            connection.plugAttr = newName
                        connection.updatePath()

            for socket in node.sockets.values():
                socket.update()
                if socket.connections:
                    for connection in socket.connections:
                        if isinstance(connection.source, SocketItem):
                            connection.source = socket
                            connection.source_point = socket.center()
                        else:
                            connection.target = socket
                            connection.target_point = socket.center()
                        if newName:
                            connection.socketAttr = newName
                        connection.updatePath()

            self.scene().update()

        node.update()

        # Emit pyqtSignal.
        if newIndex:
            self.pyqtSignal_AttrEdited.emit(node.name, index, newIndex)
        else:
            self.pyqtSignal_AttrEdited.emit(node.name, index, index)


    # GRAPH
    def saveGraph(self, filePath=&#39;path&#39;):
        &#34;&#34;&#34;
        Get all the current graph infos and store them in a .json file
        at the given location.

        :type  filePath: str.
        :param filePath: The path where you want to save your graph at.

        &#34;&#34;&#34;
        data = dict()

        # Store nodes data.
        data[&#39;NODES&#39;] = dict()

        nodes = self.scene().nodes.keys()
        for node in nodes:
            nodeInst = self.scene().nodes[node]
            preset = nodeInst.nodePreset
            nodeAlternate = nodeInst.alternate

            data[&#39;NODES&#39;][node] = {&#39;preset&#39;: preset,
                                   &#39;position&#39;: [nodeInst.pos().x(), nodeInst.pos().y()],
                                   &#39;alternate&#39;: nodeAlternate,
                                   &#39;attributes&#39;: []}

            attrs = nodeInst.attrs
            for attr in attrs:
                attrData = nodeInst.attrsData[attr]

                # serialize dataType if needed.
                if isinstance(attrData[&#39;dataType&#39;], type):
                    attrData[&#39;dataType&#39;] = str(attrData[&#39;dataType&#39;])

                data[&#39;NODES&#39;][node][&#39;attributes&#39;].append(attrData)


        # Store connections data.
        data[&#39;CONNECTIONS&#39;] = self.evaluateGraph()


        # Save data.
        try:
            utils._saveData(filePath=filePath, data=data)
        except:
            print(&#39;Invalid path : {0}&#39;.format(filePath))
            print(&#39;Save aborted !&#39;)
            return False

        # Emit pyqtSignal.
        self.pyqtSignal_GraphSaved.emit()

    def loadGraph(self, filePath=&#39;path&#39;):
        &#34;&#34;&#34;
        Get all the stored info from the .json file at the given location
        and recreate the graph as saved.

        :type  filePath: str.
        :param filePath: The path where you want to load your graph from.

        &#34;&#34;&#34;
        # Load data.
        if os.path.exists(filePath):
            data = utils._loadData(filePath=filePath)
        else:
            print(&#39;Invalid path : {0}&#39;.format(filePath))
            print(&#39;Load aborted !&#39;)
            return False

        # Apply nodes data.
        nodesData = data[&#39;NODES&#39;]
        nodesName = nodesData.keys()

        for name in nodesName:
            preset = nodesData[name][&#39;preset&#39;]
            position = nodesData[name][&#39;position&#39;]
            position = QtCore.QPointF(position[0], position[1])
            alternate = nodesData[name][&#39;alternate&#39;]

            node = self.createNode(name=name,
                                   preset=preset,
                                   position=position,
                                   alternate=alternate)

            # Apply attributes data.
            attrsData = nodesData[name][&#39;attributes&#39;]

            for attrData in attrsData:
                index = attrsData.index(attrData)
                name = attrData[&#39;name&#39;]
                plug = attrData[&#39;plug&#39;]
                socket = attrData[&#39;socket&#39;]
                preset = attrData[&#39;preset&#39;]
                dataType = attrData[&#39;dataType&#39;]
                plugMaxConnections = attrData[&#39;plugMaxConnections&#39;]
                socketMaxConnections = attrData[&#39;socketMaxConnections&#39;]

                # un-serialize data type if needed
                if (isinstance(dataType, str) and dataType.find(&#39;&lt;&#39;) == 0):
                    dataType = eval(str(dataType.split(&#39;\&#39;&#39;)[1]))

                self.createAttribute(node=node,
                                     name=name,
                                     index=index,
                                     preset=preset,
                                     plug=plug,
                                     socket=socket,
                                     dataType=dataType,
                                     plugMaxConnections=plugMaxConnections,
                                     socketMaxConnections=socketMaxConnections
                                     )

        # Apply connections data.
        connectionsData = data[&#39;CONNECTIONS&#39;]

        for connection in connectionsData:
            source = connection[0]
            sourceNode = source.split(&#39;.&#39;)[0]
            sourceAttr = source.split(&#39;.&#39;)[1]

            target = connection[1]
            targetNode = target.split(&#39;.&#39;)[0]
            targetAttr = target.split(&#39;.&#39;)[1]

            self.createConnection(sourceNode, sourceAttr,
                                  targetNode, targetAttr)

        self.scene().update()

        # Emit pyqtSignal.
        self.pyqtSignal_GraphLoaded.emit()

    def createConnection(self, sourceNode, sourceAttr, targetNode, targetAttr):
        &#34;&#34;&#34;
        Create a manual connection.

        :type  sourceNode: str.
        :param sourceNode: Node that emits the connection.

        :type  sourceAttr: str.
        :param sourceAttr: Attribute that emits the connection.

        :type  targetNode: str.
        :param targetNode: Node that receives the connection.

        :type  targetAttr: str.
        :param targetAttr: Attribute that receives the connection.

        &#34;&#34;&#34;
        plug = self.scene().nodes[sourceNode].plugs[sourceAttr]
        socket = self.scene().nodes[targetNode].sockets[targetAttr]

        connection = ConnectionItem(plug.center(), socket.center(), plug, socket)

        connection.plugNode = plug.parentItem().name
        connection.plugAttr = plug.attribute
        connection.socketNode = socket.parentItem().name
        connection.socketAttr = socket.attribute

        plug.connect(socket, connection)
        socket.connect(plug, connection)

        connection.updatePath()

        self.scene().addItem(connection)

        return connection

    def evaluateGraph(self):
        &#34;&#34;&#34;
        Create a list of connection tuples.
        [(&#34;sourceNode.attribute&#34;, &#34;TargetNode.attribute&#34;), ...]

        &#34;&#34;&#34;
        scene = self.scene()

        data = list()

        for item in scene.items():
            if isinstance(item, ConnectionItem):
                connection = item

                data.append(connection._outputConnectionData())

        # Emit pyqtSignal
        self.pyqtSignal_GraphEvaluated.emit()

        return data

    def clearGraph(self):
        &#34;&#34;&#34;
        Clear the graph.

        &#34;&#34;&#34;
        self.scene().clear()
        self.scene().nodes = dict()

        # Emit pyqtSignal.
        self.pyqtSignal_GraphCleared.emit()

    ##################################################################
    # END API
    ##################################################################


class NodeScene(QtWidgets.QGraphicsScene):

    &#34;&#34;&#34;
    The scene displaying all the nodes.

    &#34;&#34;&#34;
    pyqtSignal_NodeMoved = QtCore.pyqtSignal(str, object)

    def __init__(self, parent):
        &#34;&#34;&#34;
        Initialize the class.

        &#34;&#34;&#34;
        super(NodeScene, self).__init__(parent)

        # General.
        self.gridSize = parent.config[&#39;grid_size&#39;]

        # Nodes storage.
        self.nodes = dict()

    def dragEnterEvent(self, event):
        &#34;&#34;&#34;
        Make the dragging of nodes into the scene possible.

        &#34;&#34;&#34;
        event.setDropAction(QtCore.Qt.MoveAction)
        event.accept()

    def dragMoveEvent(self, event):
        &#34;&#34;&#34;
        Make the dragging of nodes into the scene possible.

        &#34;&#34;&#34;
        event.setDropAction(QtCore.Qt.MoveAction)
        event.accept()

    def dropEvent(self, event):
        &#34;&#34;&#34;
        Create a node from the dropped item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        self.pyqtSignal_Dropped.emit(event.scenePos())

        event.accept()

    def drawBackground(self, painter, rect):
        &#34;&#34;&#34;
        Draw a grid in the background.

        &#34;&#34;&#34;
        config = self.parent().config

        self._brush = QtGui.QBrush()
        self._brush.setStyle(QtCore.Qt.SolidPattern)
        self._brush.setColor(utils._convertDataToColor(config[&#39;bg_color&#39;]))

        painter.fillRect(rect, self._brush)

        if self.views()[0].gridVisToggle:
            leftLine = rect.left() - rect.left() % self.gridSize
            topLine = rect.top() - rect.top() % self.gridSize
            lines = list()

            i = int(leftLine)
            while i &lt; int(rect.right()):
                lines.append(QtCore.QLineF(i, rect.top(), i, rect.bottom()))
                i += self.gridSize

            u = int(topLine)
            while u &lt; int(rect.bottom()):
                lines.append(QtCore.QLineF(rect.left(), u, rect.right(), u))
                u += self.gridSize

            self.pen = QtGui.QPen()
            self.pen.setColor(utils._convertDataToColor(config[&#39;grid_color&#39;]))
            self.pen.setWidth(0)
            painter.setPen(self.pen)
            painter.drawLines(lines)

    def updateScene(self):
        &#34;&#34;&#34;
        Update the connections position.

        &#34;&#34;&#34;
        for connection in [i for i in self.items() if isinstance(i, ConnectionItem)]:
            connection.target_point = connection.target.center()
            connection.source_point = connection.source.center()
            connection.updatePath()


class NodeItem(QtWidgets.QGraphicsItem):

    &#34;&#34;&#34;
    A graphic representation of a node containing attributes.

    &#34;&#34;&#34;

    def __init__(self, name, alternate, preset, config):
        &#34;&#34;&#34;
        Initialize the class.

        :type  name: str.
        :param name: The name of the node. The name has to be unique
                     as it is used as a key to store the node object.

        :type  alternate: bool.
        :param alternate: The attribute color alternate state, if True,
                          every 2 attribute the color will be slightly
                          darker.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        &#34;&#34;&#34;
        super(NodeItem, self).__init__()

        self.setZValue(1)

        # Storage
        self.name = name
        self.alternate = alternate
        self.nodePreset = preset
        self.attrPreset = None

        # Attributes storage.
        self.attrs = list()
        self.attrsData = dict()
        self.attrCount = 0
        self.currentDataType = None

        self.plugs = dict()
        self.sockets = dict()

        # Methods.
        self._createStyle(config)

    @property
    def height(self):
        &#34;&#34;&#34;
        Increment the final height of the node every time an attribute
        is created.

        &#34;&#34;&#34;
        if self.attrCount &gt; 0:
            return (self.baseHeight +
                    self.attrHeight * self.attrCount +
                    self.border +
                    0.5 * self.radius)
        else:
            return self.baseHeight

    @property
    def pen(self):
        &#34;&#34;&#34;
        Return the pen based on the selection state of the node.

        &#34;&#34;&#34;
        if self.isSelected():
            return self._penSel
        else:
            return self._pen

    def _createStyle(self, config):
        &#34;&#34;&#34;
        Read the node style from the configuration file.

        &#34;&#34;&#34;
        self.setAcceptHoverEvents(True)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)

        # Dimensions.
        self.baseWidth  = config[&#39;node_width&#39;]
        self.baseHeight = config[&#39;node_height&#39;]
        self.attrHeight = config[&#39;node_attr_height&#39;]
        self.border = config[&#39;node_border&#39;]
        self.radius = config[&#39;node_radius&#39;]

        self.nodeCenter = QtCore.QPointF()
        self.nodeCenter.setX(self.baseWidth / 2.0)
        self.nodeCenter.setY(self.height / 2.0)

        self._brush = QtGui.QBrush()
        self._brush.setStyle(QtCore.Qt.SolidPattern)
        self._brush.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;bg&#39;]))

        self._pen = QtGui.QPen()
        self._pen.setStyle(QtCore.Qt.SolidLine)
        self._pen.setWidth(self.border)
        self._pen.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;border&#39;]))

        self._penSel = QtGui.QPen()
        self._penSel.setStyle(QtCore.Qt.SolidLine)
        self._penSel.setWidth(self.border)
        self._penSel.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;border_sel&#39;]))

        self._textPen = QtGui.QPen()
        self._textPen.setStyle(QtCore.Qt.SolidLine)
        self._textPen.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;text&#39;]))

        self._nodeTextFont = QtGui.QFont(config[&#39;node_font&#39;], config[&#39;node_font_size&#39;], QtGui.QFont.Bold)
        self._attrTextFont = QtGui.QFont(config[&#39;attr_font&#39;], config[&#39;attr_font_size&#39;], QtGui.QFont.Normal)

        self._attrBrush = QtGui.QBrush()
        self._attrBrush.setStyle(QtCore.Qt.SolidPattern)

        self._attrBrushAlt = QtGui.QBrush()
        self._attrBrushAlt.setStyle(QtCore.Qt.SolidPattern)

        self._attrPen = QtGui.QPen()
        self._attrPen.setStyle(QtCore.Qt.SolidLine)

    def _createAttribute(self, name, index, preset, plug, socket, dataType, plugMaxConnections, socketMaxConnections):
        &#34;&#34;&#34;
        Create an attribute by expanding the node, adding a label and
        connection items.

        :type  name: str.
        :param name: The name of the attribute. The name has to be
                     unique as it is used as a key to store the node
                     object.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  plug: bool.
        :param plug: Whether or not this attribute can emit connections.

        :type  socket: bool.
        :param socket: Whether or not this attribute can receive
                       connections.

        :type  dataType: type.
        :param dataType: Type of the data represented by this attribute
                         in order to highlight attributes of the same
                         type while performing a connection.

        &#34;&#34;&#34;
        if name in self.attrs:
            print(&#39;An attribute with the same name already exists on this node : {0}&#39;.format(name))
            print(&#39;Attribute creation aborted !&#39;)
            return

        self.attrPreset = preset

        # Create a plug connection item.
        if plug:
            plugInst = PlugItem(parent=self,
                                attribute=name,
                                index=self.attrCount,
                                preset=preset,
                                dataType=dataType,
                                maxConnections=plugMaxConnections)

            self.plugs[name] = plugInst

        # Create a socket connection item.
        if socket:
            socketInst = SocketItem(parent=self,
                                    attribute=name,
                                    index=self.attrCount,
                                    preset=preset,
                                    dataType=dataType,
                                    maxConnections=socketMaxConnections)

            self.sockets[name] = socketInst

        self.attrCount += 1

        # Add the attribute based on its index.
        if index == -1 or index &gt; self.attrCount:
            self.attrs.append(name)
        else:
            self.attrs.insert(index, name)

        # Store attr data.
        self.attrsData[name] = {&#39;name&#39;: name,
                                &#39;socket&#39;: socket,
                                &#39;plug&#39;: plug,
                                &#39;preset&#39;: preset,
                                &#39;dataType&#39;: dataType,
                                &#39;plugMaxConnections&#39;: plugMaxConnections,
                                &#39;socketMaxConnections&#39;: socketMaxConnections
                                }

        # Update node height.
        self.update()

    def _deleteAttribute(self, index):
        &#34;&#34;&#34;
        Remove an attribute by reducing the node, removing the label
        and the connection items.

        :type  index: int.
        :param index: The index of the attribute in the node.

        &#34;&#34;&#34;
        name = self.attrs[index]

        # Remove socket and its connections.
        if name in self.sockets.keys():
            for connection in self.sockets[name].connections:
                connection._remove()

            self.scene().removeItem(self.sockets[name])
            self.sockets.pop(name)

        # Remove plug and its connections.
        if name in self.plugs.keys():
            for connection in self.plugs[name].connections:
                connection._remove()

            self.scene().removeItem(self.plugs[name])
            self.plugs.pop(name)

        # Reduce node height.
        if self.attrCount &gt; 0:
            self.attrCount -= 1

        # Remove attribute from node.
        if name in self.attrs:
            self.attrs.remove(name)

        self.update()

    def _remove(self):
        &#34;&#34;&#34;
        Remove this node instance from the scene.

        Make sure that all the connections to this node are also removed
        in the process

        &#34;&#34;&#34;
        self.scene().nodes.pop(self.name)

        # Remove all sockets connections.
        for socket in self.sockets.values():
            while len(socket.connections)&gt;0:
                socket.connections[0]._remove()

        # Remove all plugs connections.
        for plug in self.plugs.values():
            while len(plug.connections)&gt;0:
                plug.connections[0]._remove()

        # Remove node.
        scene = self.scene()
        scene.removeItem(self)
        scene.update()

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        rect = QtCore.QRect(0, 0, self.baseWidth, self.height)
        rect = QtCore.QRectF(rect)
        return rect

    def shape(self):
        &#34;&#34;&#34;
        The shape of the item.

        &#34;&#34;&#34;
        path = QtGui.QPainterPath()
        path.addRect(self.boundingRect())
        return path

    def paint(self, painter, option, widget):
        &#34;&#34;&#34;
        Paint the node and attributes.

        &#34;&#34;&#34;
        # Node base.
        painter.setBrush(self._brush)
        painter.setPen(self.pen)

        painter.drawRoundedRect(0, 0,
                                self.baseWidth,
                                self.height,
                                self.radius,
                                self.radius)

        # Node label.
        painter.setPen(self._textPen)
        painter.setFont(self._nodeTextFont)

        metrics = QtGui.QFontMetrics(painter.font())
        text_width = metrics.boundingRect(self.name).width() + 14
        text_height = metrics.boundingRect(self.name).height() + 14
        margin = (text_width - self.baseWidth) * 0.5
        textRect = QtCore.QRect(-margin,
                                -text_height,
                                text_width,
                                text_height)

        painter.drawText(textRect,
                         QtCore.Qt.AlignCenter,
                         self.name)


        # Attributes.
        offset = 0
        for attr in self.attrs:
            nodzInst = self.scene().views()[0]
            config = nodzInst.config

            # Attribute rect.
            rect = QtCore.QRect(self.border / 2,
                                self.baseHeight - self.radius + offset,
                                self.baseWidth - self.border,
                                self.attrHeight)



            attrData = self.attrsData[attr]
            name = attr

            preset = attrData[&#39;preset&#39;]


            # Attribute base.
            self._attrBrush.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;]))
            if self.alternate:
                self._attrBrushAlt.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;], True, config[&#39;alternate_value&#39;]))

            self._attrPen.setColor(utils._convertDataToColor([0, 0, 0, 0]))
            painter.setPen(self._attrPen)
            painter.setBrush(self._attrBrush)
            if (offset / self.attrHeight) % 2:
                painter.setBrush(self._attrBrushAlt)

            painter.drawRect(rect)

            # Attribute label.
            painter.setPen(utils._convertDataToColor(config[preset][&#39;text&#39;]))
            painter.setFont(self._attrTextFont)

            # Search non-connectable attributes.
            if nodzInst.drawingConnection:
                if self == nodzInst.currentHoveredNode:
                    if (attrData[&#39;dataType&#39;] != nodzInst.sourcepyqtSlot.dataType or
                        (nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;plug&#39; and attrData[&#39;socket&#39;] == False or
                         nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;socket&#39; and attrData[&#39;plug&#39;] == False)):
                        # Set non-connectable attributes color.
                        painter.setPen(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))

            textRect = QtCore.QRect(rect.left() + self.radius,
                                     rect.top(),
                                     rect.width() - 2*self.radius,
                                     rect.height())
            painter.drawText(textRect, QtCore.Qt.AlignVCenter, name)

            offset += self.attrHeight

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Keep the selected node on top of the others.

        &#34;&#34;&#34;
        nodes = self.scene().nodes
        for node in nodes.values():
            node.setZValue(1)

        for item in self.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(1)

        self.setZValue(2)

        super(NodeItem, self).mousePressEvent(event)

    def mouseDoubleClickEvent(self, event):
        &#34;&#34;&#34;
        Emit a pyqtSignal.

        &#34;&#34;&#34;
        super(NodeItem, self).mouseDoubleClickEvent(event)
        self.scene().parent().pyqtSignal_NodeDoubleClicked.emit(self.name)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        if self.scene().views()[0].gridVisToggle:
            if self.scene().views()[0].gridSnapToggle or self.scene().views()[0]._nodeSnap:
                gridSize = self.scene().gridSize

                currentPos = self.mapToScene(event.pos().x() - self.baseWidth / 2,
                                             event.pos().y() - self.height / 2)

                snap_x = (round(currentPos.x() / gridSize) * gridSize) - gridSize/4
                snap_y = (round(currentPos.y() / gridSize) * gridSize) - gridSize/4
                snap_pos = QtCore.QPointF(snap_x, snap_y)
                self.setPos(snap_pos)

                self.scene().updateScene()
            else:
                self.scene().updateScene()
                super(NodeItem, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        # Emit node moved pyqtSignal.
        self.scene().pyqtSignal_NodeMoved.emit(self.name, self.pos())
        super(NodeItem, self).mouseReleaseEvent(event)

    def hoverLeaveEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]

        for item in nodzInst.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(0)

        super(NodeItem, self).hoverLeaveEvent(event)


class pyqtSlotItem(QtWidgets.QGraphicsItem):

    &#34;&#34;&#34;
    The base class for graphics item representing attributes hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, preset, index, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the class.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(pyqtSlotItem, self).__init__(parent)

        # Status.
        self.setAcceptHoverEvents(True)

        # Storage.
        self.pyqtSlotType = None
        self.attribute = attribute
        self.preset = preset
        self.index = index
        self.dataType = dataType

        # Style.
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)

        self.pen = QtGui.QPen()
        self.pen.setStyle(QtCore.Qt.SolidLine)

        # Connections storage.
        self.connected_pyqtSlots = list()
        self.newConnection = None
        self.connections = list()
        self.maxConnections = maxConnections

    def accepts(self, pyqtSlot_item):
        &#34;&#34;&#34;
        Only accepts plug items that belong to other nodes, and only if the max connections count is not reached yet.

        &#34;&#34;&#34;
        # no plug on plug or socket on socket
        hasPlugItem = isinstance(self, PlugItem) or isinstance(pyqtSlot_item, PlugItem)
        hasSocketItem = isinstance(self, SocketItem) or isinstance(pyqtSlot_item, SocketItem)
        if not (hasPlugItem and hasSocketItem):
            return False

        # no self connection
        if self.parentItem() == pyqtSlot_item.parentItem():
            return False

        #no more than maxConnections
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            return False

        #no connection with different types
        if pyqtSlot_item.dataType != self.dataType:
            return False

        #otherwize, all fine.
        return True

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Start the connection process.

        &#34;&#34;&#34;
        if event.button() == QtCore.Qt.LeftButton:
            self.newConnection = ConnectionItem(self.center(),
                                                self.mapToScene(event.pos()),
                                                self,
                                                None)

            self.connections.append(self.newConnection)
            self.scene().addItem(self.newConnection)

            nodzInst = self.scene().views()[0]
            nodzInst.drawingConnection = True
            nodzInst.sourcepyqtSlot = self
            nodzInst.currentDataType = self.dataType
        else:
            super(pyqtSlotItem, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Update the new connection&#39;s end point position.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        config = nodzInst.config
        if nodzInst.drawingConnection:
            mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                                  bbSize=config[&#39;mouse_bounding_box&#39;])

            # Get nodes in pointer&#39;s bounding box.
            targets = self.scene().items(mbb)

            if any(isinstance(target, NodeItem) for target in targets):
                if self.parentItem() not in targets:
                    for target in targets:
                        if isinstance(target, NodeItem):
                            nodzInst.currentHoveredNode = target
            else:
                nodzInst.currentHoveredNode = None

            # Set connection&#39;s end point.
            self.newConnection.target_point = self.mapToScene(event.pos())
            self.newConnection.updatePath()
        else:
            super(pyqtSlotItem, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Apply the connection if target_pyqtSlot is valid.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        if event.button() == QtCore.Qt.LeftButton:
            nodzInst.drawingConnection = False
            nodzInst.currentDataType = None

            target = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

            if not isinstance(target, pyqtSlotItem):
                self.newConnection._remove()
                super(pyqtSlotItem, self).mouseReleaseEvent(event)
                return

            if target.accepts(self):
                self.newConnection.target = target
                self.newConnection.source = self
                self.newConnection.target_point = target.center()
                self.newConnection.source_point = self.center()

                # Perform the ConnectionItem.
                self.connect(target, self.newConnection)
                target.connect(self, self.newConnection)

                self.newConnection.updatePath()
            else:
                self.newConnection._remove()
        else:
            super(pyqtSlotItem, self).mouseReleaseEvent(event)

        nodzInst.currentHoveredNode = None

    def shape(self):
        &#34;&#34;&#34;
        The shape of the pyqtSlot is a circle.

        &#34;&#34;&#34;
        path = QtGui.QPainterPath()
        path.addRect(self.boundingRect())
        return path

    def paint(self, painter, option, widget):
        &#34;&#34;&#34;
        Paint the pyqtSlot.

        &#34;&#34;&#34;
        painter.setBrush(self.brush)
        painter.setPen(self.pen)

        nodzInst = self.scene().views()[0]
        config = nodzInst.config
        if nodzInst.drawingConnection:
            if self.parentItem() == nodzInst.currentHoveredNode:
                painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
                if (self.pyqtSlotType == nodzInst.sourcepyqtSlot.pyqtSlotType or (self.pyqtSlotType != nodzInst.sourcepyqtSlot.pyqtSlotType and self.dataType != nodzInst.sourcepyqtSlot.dataType)):
                    painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
                else:
                    _penValid = QtGui.QPen()
                    _penValid.setStyle(QtCore.Qt.SolidLine)
                    _penValid.setWidth(2)
                    _penValid.setColor(QtGui.QColor(255, 255, 255, 255))
                    painter.setPen(_penValid)
                    painter.setBrush(self.brush)

        painter.drawEllipse(self.boundingRect())

    def center(self):
        &#34;&#34;&#34;
        Return The center of the pyqtSlot.

        &#34;&#34;&#34;
        rect = self.boundingRect()
        center = QtCore.QPointF(rect.x() + rect.width() * 0.5,
                                rect.y() + rect.height() * 0.5)

        return self.mapToScene(center)


class PlugItem(pyqtSlotItem):

    &#34;&#34;&#34;
    A graphics item representing an attribute out hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, index, preset, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the class.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(PlugItem, self).__init__(parent, attribute, preset, index, dataType, maxConnections)

        # Storage.
        self.attributte = attribute
        self.preset = preset
        self.pyqtSlotType = &#39;plug&#39;

        # Methods.
        self._createStyle(parent)

    def _createStyle(self, parent):
        &#34;&#34;&#34;
        Read the attribute style from the configuration file.

        &#34;&#34;&#34;
        config = parent.scene().views()[0].config
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)
        self.brush.setColor(utils._convertDataToColor(config[self.preset][&#39;plug&#39;]))

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        width = height = self.parentItem().attrHeight / 2.0

        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        x = self.parentItem().baseWidth - (width / 2.0)
        y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
             self.parentItem().attrHeight / 4 +
             self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight)

        rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
        return rect

    def connect(self, socket_item, connection):
        &#34;&#34;&#34;
        Connect to the given socket_item.

        &#34;&#34;&#34;
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            # Already connected.
            self.connections[self.maxConnections-1]._remove()

        # Populate connection.
        connection.socketItem = socket_item
        connection.plugNode = self.parentItem().name
        connection.plugAttr = self.attribute

        # Add socket to connected pyqtSlots.
        if socket_item in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(socket_item)
        self.connected_pyqtSlots.append(socket_item)

        # Add connection.
        if connection not in self.connections:
            self.connections.append(connection)

        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_PlugConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    def disconnect(self, connection):
        &#34;&#34;&#34;
        Disconnect the given connection from this plug item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_PlugDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

        # Remove connected socket from plug
        if connection.socketItem in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(connection.socketItem)
        # Remove connection
        self.connections.remove(connection)


class SocketItem(pyqtSlotItem):

    &#34;&#34;&#34;
    A graphics item representing an attribute in hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, index, preset, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the socket.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(SocketItem, self).__init__(parent, attribute, preset, index, dataType, maxConnections)

        # Storage.
        self.attributte = attribute
        self.preset = preset
        self.pyqtSlotType = &#39;socket&#39;

        # Methods.
        self._createStyle(parent)

    def _createStyle(self, parent):
        &#34;&#34;&#34;
        Read the attribute style from the configuration file.

        &#34;&#34;&#34;
        config = parent.scene().views()[0].config
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)
        self.brush.setColor(utils._convertDataToColor(config[self.preset][&#39;socket&#39;]))

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        width = height = self.parentItem().attrHeight / 2.0

        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        x = - width / 2.0
        y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
            (self.parentItem().attrHeight/4) +
             self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight )

        rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
        return rect

    def connect(self, plug_item, connection):
        &#34;&#34;&#34;
        Connect to the given plug item.

        &#34;&#34;&#34;
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            # Already connected.
            self.connections[self.maxConnections-1]._remove()

        # Populate connection.
        connection.plugItem = plug_item
        connection.socketNode = self.parentItem().name
        connection.socketAttr = self.attribute

        # Add plug to connected pyqtSlots.
        self.connected_pyqtSlots.append(plug_item)

        # Add connection.
        if connection not in self.connections:
            self.connections.append(connection)

        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_SocketConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    def disconnect(self, connection):
        &#34;&#34;&#34;
        Disconnect the given connection from this socket item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_SocketDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

        # Remove connected plugs
        if connection.plugItem in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(connection.plugItem)
        # Remove connections
        self.connections.remove(connection)


class ConnectionItem(QtWidgets.QGraphicsPathItem):

    &#34;&#34;&#34;
    A graphics path representing a connection between two attributes.

    &#34;&#34;&#34;

    def __init__(self, source_point, target_point, source, target):
        &#34;&#34;&#34;
        Initialize the class.

        :param sourcePoint: Source position of the connection.
        :type  sourcePoint: QPoint.

        :param targetPoint: Target position of the connection
        :type  targetPoint: QPoint.

        :param source: Source item (plug or socket).
        :type  source: class.

        :param target: Target item (plug or socket).
        :type  target: class.

        &#34;&#34;&#34;
        super(ConnectionItem, self).__init__()

        self.setZValue(1)

        # Storage.
        self.socketNode = None
        self.socketAttr = None
        self.plugNode = None
        self.plugAttr = None

        self.source_point = source_point
        self.target_point = target_point
        self.source = source
        self.target = target

        self.plugItem = None
        self.socketItem = None

        self.movable_point = None

        self.data = tuple()

        # Methods.
        self._createStyle()

    def _createStyle(self):
        &#34;&#34;&#34;
        Read the connection style from the configuration file.

        &#34;&#34;&#34;
        config = self.source.scene().views()[0].config
        self.setAcceptHoverEvents(True)
        self.setZValue(-1)

        self._pen = QtGui.QPen(utils._convertDataToColor(config[&#39;connection_color&#39;]))
        self._pen.setWidth(config[&#39;connection_width&#39;])

    def _outputConnectionData(self):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        return (&#34;{0}.{1}&#34;.format(self.plugNode, self.plugAttr),
                &#34;{0}.{1}&#34;.format(self.socketNode, self.socketAttr))

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Snap the Connection to the mouse.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]

        for item in nodzInst.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(0)

        nodzInst.drawingConnection = True

        d_to_target = (event.pos() - self.target_point).manhattanLength()
        d_to_source = (event.pos() - self.source_point).manhattanLength()
        if d_to_target &lt; d_to_source:
            self.target_point = event.pos()
            self.movable_point = &#39;target_point&#39;
            self.target.disconnect(self)
            self.target = None
            nodzInst.sourcepyqtSlot = self.source
        else:
            self.source_point = event.pos()
            self.movable_point = &#39;source_point&#39;
            self.source.disconnect(self)
            self.source = None
            nodzInst.sourcepyqtSlot = self.target

        self.updatePath()

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Move the Connection with the mouse.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                              bbSize=config[&#39;mouse_bounding_box&#39;])

        # Get nodes in pointer&#39;s bounding box.
        targets = self.scene().items(mbb)

        if any(isinstance(target, NodeItem) for target in targets):

            if nodzInst.sourcepyqtSlot.parentItem() not in targets:
                for target in targets:
                    if isinstance(target, NodeItem):
                        nodzInst.currentHoveredNode = target
        else:
            nodzInst.currentHoveredNode = None

        if self.movable_point == &#39;target_point&#39;:
            self.target_point = event.pos()
        else:
            self.source_point = event.pos()

        self.updatePath()

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Create a Connection if possible, otherwise delete it.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        nodzInst.drawingConnection = False

        pyqtSlot = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

        if not isinstance(pyqtSlot, pyqtSlotItem):
            self._remove()
            self.updatePath()
            super(ConnectionItem, self).mouseReleaseEvent(event)
            return

        if self.movable_point == &#39;target_point&#39;:
            if pyqtSlot.accepts(self.source):
                # Plug reconnection.
                self.target = pyqtSlot
                self.target_point = pyqtSlot.center()
                plug = self.source
                socket = self.target

                # Reconnect.
                socket.connect(plug, self)

                self.updatePath()
            else:
                self._remove()

        else:
            if pyqtSlot.accepts(self.target):
                # Socket Reconnection
                self.source = pyqtSlot
                self.source_point = pyqtSlot.center()
                socket = self.target
                plug = self.source

                # Reconnect.
                plug.connect(socket, self)

                self.updatePath()
            else:
                self._remove()

    def _remove(self):
        &#34;&#34;&#34;
        Remove this Connection from the scene.

        &#34;&#34;&#34;
        if self.source is not None:
            self.source.disconnect(self)
        if self.target is not None:
            self.target.disconnect(self)

        scene = self.scene()
        scene.removeItem(self)
        scene.update()

    def updatePath(self):
        &#34;&#34;&#34;
        Update the path.

        &#34;&#34;&#34;
        self.setPen(self._pen)

        path = QtGui.QPainterPath()
        path.moveTo(self.source_point)
        dx = (self.target_point.x() - self.source_point.x()) * 0.5
        dy = self.target_point.y() - self.source_point.y()
        ctrl1 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 0)
        ctrl2 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 1)
        path.cubicTo(ctrl1, ctrl2, self.target_point)

        self.setPath(path)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem"><code class="flex name class">
<span>class <span class="ident">ConnectionItem</span></span>
<span>(</span><span>source_point, target_point, source, target)</span>
</code></dt>
<dd>
<div class="desc"><p>A graphics path representing a connection between two attributes.</p>
<p>Initialize the class.</p>
<p>:param sourcePoint: Source position of the connection.
:type
sourcePoint: QPoint.</p>
<p>:param targetPoint: Target position of the connection
:type
targetPoint: QPoint.</p>
<p>:param source: Source item (plug or socket).
:type
source: class.</p>
<p>:param target: Target item (plug or socket).
:type
target: class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionItem(QtWidgets.QGraphicsPathItem):

    &#34;&#34;&#34;
    A graphics path representing a connection between two attributes.

    &#34;&#34;&#34;

    def __init__(self, source_point, target_point, source, target):
        &#34;&#34;&#34;
        Initialize the class.

        :param sourcePoint: Source position of the connection.
        :type  sourcePoint: QPoint.

        :param targetPoint: Target position of the connection
        :type  targetPoint: QPoint.

        :param source: Source item (plug or socket).
        :type  source: class.

        :param target: Target item (plug or socket).
        :type  target: class.

        &#34;&#34;&#34;
        super(ConnectionItem, self).__init__()

        self.setZValue(1)

        # Storage.
        self.socketNode = None
        self.socketAttr = None
        self.plugNode = None
        self.plugAttr = None

        self.source_point = source_point
        self.target_point = target_point
        self.source = source
        self.target = target

        self.plugItem = None
        self.socketItem = None

        self.movable_point = None

        self.data = tuple()

        # Methods.
        self._createStyle()

    def _createStyle(self):
        &#34;&#34;&#34;
        Read the connection style from the configuration file.

        &#34;&#34;&#34;
        config = self.source.scene().views()[0].config
        self.setAcceptHoverEvents(True)
        self.setZValue(-1)

        self._pen = QtGui.QPen(utils._convertDataToColor(config[&#39;connection_color&#39;]))
        self._pen.setWidth(config[&#39;connection_width&#39;])

    def _outputConnectionData(self):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        return (&#34;{0}.{1}&#34;.format(self.plugNode, self.plugAttr),
                &#34;{0}.{1}&#34;.format(self.socketNode, self.socketAttr))

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Snap the Connection to the mouse.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]

        for item in nodzInst.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(0)

        nodzInst.drawingConnection = True

        d_to_target = (event.pos() - self.target_point).manhattanLength()
        d_to_source = (event.pos() - self.source_point).manhattanLength()
        if d_to_target &lt; d_to_source:
            self.target_point = event.pos()
            self.movable_point = &#39;target_point&#39;
            self.target.disconnect(self)
            self.target = None
            nodzInst.sourcepyqtSlot = self.source
        else:
            self.source_point = event.pos()
            self.movable_point = &#39;source_point&#39;
            self.source.disconnect(self)
            self.source = None
            nodzInst.sourcepyqtSlot = self.target

        self.updatePath()

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Move the Connection with the mouse.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                              bbSize=config[&#39;mouse_bounding_box&#39;])

        # Get nodes in pointer&#39;s bounding box.
        targets = self.scene().items(mbb)

        if any(isinstance(target, NodeItem) for target in targets):

            if nodzInst.sourcepyqtSlot.parentItem() not in targets:
                for target in targets:
                    if isinstance(target, NodeItem):
                        nodzInst.currentHoveredNode = target
        else:
            nodzInst.currentHoveredNode = None

        if self.movable_point == &#39;target_point&#39;:
            self.target_point = event.pos()
        else:
            self.source_point = event.pos()

        self.updatePath()

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Create a Connection if possible, otherwise delete it.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        nodzInst.drawingConnection = False

        pyqtSlot = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

        if not isinstance(pyqtSlot, pyqtSlotItem):
            self._remove()
            self.updatePath()
            super(ConnectionItem, self).mouseReleaseEvent(event)
            return

        if self.movable_point == &#39;target_point&#39;:
            if pyqtSlot.accepts(self.source):
                # Plug reconnection.
                self.target = pyqtSlot
                self.target_point = pyqtSlot.center()
                plug = self.source
                socket = self.target

                # Reconnect.
                socket.connect(plug, self)

                self.updatePath()
            else:
                self._remove()

        else:
            if pyqtSlot.accepts(self.target):
                # Socket Reconnection
                self.source = pyqtSlot
                self.source_point = pyqtSlot.center()
                socket = self.target
                plug = self.source

                # Reconnect.
                plug.connect(socket, self)

                self.updatePath()
            else:
                self._remove()

    def _remove(self):
        &#34;&#34;&#34;
        Remove this Connection from the scene.

        &#34;&#34;&#34;
        if self.source is not None:
            self.source.disconnect(self)
        if self.target is not None:
            self.target.disconnect(self)

        scene = self.scene()
        scene.removeItem(self)
        scene.update()

    def updatePath(self):
        &#34;&#34;&#34;
        Update the path.

        &#34;&#34;&#34;
        self.setPen(self._pen)

        path = QtGui.QPainterPath()
        path.moveTo(self.source_point)
        dx = (self.target_point.x() - self.source_point.x()) * 0.5
        dy = self.target_point.y() - self.source_point.y()
        ctrl1 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 0)
        ctrl2 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 1)
        path.cubicTo(ctrl1, ctrl2, self.target_point)

        self.setPath(path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsPathItem</li>
<li>PyQt5.QtWidgets.QAbstractGraphicsShapeItem</li>
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the Connection with the mouse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    &#34;&#34;&#34;
    Move the Connection with the mouse.

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]
    config = nodzInst.config

    mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                          bbSize=config[&#39;mouse_bounding_box&#39;])

    # Get nodes in pointer&#39;s bounding box.
    targets = self.scene().items(mbb)

    if any(isinstance(target, NodeItem) for target in targets):

        if nodzInst.sourcepyqtSlot.parentItem() not in targets:
            for target in targets:
                if isinstance(target, NodeItem):
                    nodzInst.currentHoveredNode = target
    else:
        nodzInst.currentHoveredNode = None

    if self.movable_point == &#39;target_point&#39;:
        self.target_point = event.pos()
    else:
        self.source_point = event.pos()

    self.updatePath()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Snap the Connection to the mouse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    &#34;&#34;&#34;
    Snap the Connection to the mouse.

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]

    for item in nodzInst.scene().items():
        if isinstance(item, ConnectionItem):
            item.setZValue(0)

    nodzInst.drawingConnection = True

    d_to_target = (event.pos() - self.target_point).manhattanLength()
    d_to_source = (event.pos() - self.source_point).manhattanLength()
    if d_to_target &lt; d_to_source:
        self.target_point = event.pos()
        self.movable_point = &#39;target_point&#39;
        self.target.disconnect(self)
        self.target = None
        nodzInst.sourcepyqtSlot = self.source
    else:
        self.source_point = event.pos()
        self.movable_point = &#39;source_point&#39;
        self.source.disconnect(self)
        self.source = None
        nodzInst.sourcepyqtSlot = self.target

    self.updatePath()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Connection if possible, otherwise delete it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, event):
    &#34;&#34;&#34;
    Create a Connection if possible, otherwise delete it.

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]
    nodzInst.drawingConnection = False

    pyqtSlot = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

    if not isinstance(pyqtSlot, pyqtSlotItem):
        self._remove()
        self.updatePath()
        super(ConnectionItem, self).mouseReleaseEvent(event)
        return

    if self.movable_point == &#39;target_point&#39;:
        if pyqtSlot.accepts(self.source):
            # Plug reconnection.
            self.target = pyqtSlot
            self.target_point = pyqtSlot.center()
            plug = self.source
            socket = self.target

            # Reconnect.
            socket.connect(plug, self)

            self.updatePath()
        else:
            self._remove()

    else:
        if pyqtSlot.accepts(self.target):
            # Socket Reconnection
            self.source = pyqtSlot
            self.source_point = pyqtSlot.center()
            socket = self.target
            plug = self.source

            # Reconnect.
            plug.connect(socket, self)

            self.updatePath()
        else:
            self._remove()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.updatePath"><code class="name flex">
<span>def <span class="ident">updatePath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updatePath(self):
    &#34;&#34;&#34;
    Update the path.

    &#34;&#34;&#34;
    self.setPen(self._pen)

    path = QtGui.QPainterPath()
    path.moveTo(self.source_point)
    dx = (self.target_point.x() - self.source_point.x()) * 0.5
    dy = self.target_point.y() - self.source_point.y()
    ctrl1 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 0)
    ctrl2 = QtCore.QPointF(self.source_point.x() + dx, self.source_point.y() + dy * 1)
    path.cubicTo(ctrl1, ctrl2, self.target_point)

    self.setPath(path)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem"><code class="flex name class">
<span>class <span class="ident">NodeItem</span></span>
<span>(</span><span>name, alternate, preset, config)</span>
</code></dt>
<dd>
<div class="desc"><p>A graphic representation of a node containing attributes.</p>
<p>Initialize the class.</p>
<p>:type
name: str.
:param name: The name of the node. The name has to be unique
as it is used as a key to store the node object.</p>
<p>:type
alternate: bool.
:param alternate: The attribute color alternate state, if True,
every 2 attribute the color will be slightly
darker.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeItem(QtWidgets.QGraphicsItem):

    &#34;&#34;&#34;
    A graphic representation of a node containing attributes.

    &#34;&#34;&#34;

    def __init__(self, name, alternate, preset, config):
        &#34;&#34;&#34;
        Initialize the class.

        :type  name: str.
        :param name: The name of the node. The name has to be unique
                     as it is used as a key to store the node object.

        :type  alternate: bool.
        :param alternate: The attribute color alternate state, if True,
                          every 2 attribute the color will be slightly
                          darker.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        &#34;&#34;&#34;
        super(NodeItem, self).__init__()

        self.setZValue(1)

        # Storage
        self.name = name
        self.alternate = alternate
        self.nodePreset = preset
        self.attrPreset = None

        # Attributes storage.
        self.attrs = list()
        self.attrsData = dict()
        self.attrCount = 0
        self.currentDataType = None

        self.plugs = dict()
        self.sockets = dict()

        # Methods.
        self._createStyle(config)

    @property
    def height(self):
        &#34;&#34;&#34;
        Increment the final height of the node every time an attribute
        is created.

        &#34;&#34;&#34;
        if self.attrCount &gt; 0:
            return (self.baseHeight +
                    self.attrHeight * self.attrCount +
                    self.border +
                    0.5 * self.radius)
        else:
            return self.baseHeight

    @property
    def pen(self):
        &#34;&#34;&#34;
        Return the pen based on the selection state of the node.

        &#34;&#34;&#34;
        if self.isSelected():
            return self._penSel
        else:
            return self._pen

    def _createStyle(self, config):
        &#34;&#34;&#34;
        Read the node style from the configuration file.

        &#34;&#34;&#34;
        self.setAcceptHoverEvents(True)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable)
        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)

        # Dimensions.
        self.baseWidth  = config[&#39;node_width&#39;]
        self.baseHeight = config[&#39;node_height&#39;]
        self.attrHeight = config[&#39;node_attr_height&#39;]
        self.border = config[&#39;node_border&#39;]
        self.radius = config[&#39;node_radius&#39;]

        self.nodeCenter = QtCore.QPointF()
        self.nodeCenter.setX(self.baseWidth / 2.0)
        self.nodeCenter.setY(self.height / 2.0)

        self._brush = QtGui.QBrush()
        self._brush.setStyle(QtCore.Qt.SolidPattern)
        self._brush.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;bg&#39;]))

        self._pen = QtGui.QPen()
        self._pen.setStyle(QtCore.Qt.SolidLine)
        self._pen.setWidth(self.border)
        self._pen.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;border&#39;]))

        self._penSel = QtGui.QPen()
        self._penSel.setStyle(QtCore.Qt.SolidLine)
        self._penSel.setWidth(self.border)
        self._penSel.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;border_sel&#39;]))

        self._textPen = QtGui.QPen()
        self._textPen.setStyle(QtCore.Qt.SolidLine)
        self._textPen.setColor(utils._convertDataToColor(config[self.nodePreset][&#39;text&#39;]))

        self._nodeTextFont = QtGui.QFont(config[&#39;node_font&#39;], config[&#39;node_font_size&#39;], QtGui.QFont.Bold)
        self._attrTextFont = QtGui.QFont(config[&#39;attr_font&#39;], config[&#39;attr_font_size&#39;], QtGui.QFont.Normal)

        self._attrBrush = QtGui.QBrush()
        self._attrBrush.setStyle(QtCore.Qt.SolidPattern)

        self._attrBrushAlt = QtGui.QBrush()
        self._attrBrushAlt.setStyle(QtCore.Qt.SolidPattern)

        self._attrPen = QtGui.QPen()
        self._attrPen.setStyle(QtCore.Qt.SolidLine)

    def _createAttribute(self, name, index, preset, plug, socket, dataType, plugMaxConnections, socketMaxConnections):
        &#34;&#34;&#34;
        Create an attribute by expanding the node, adding a label and
        connection items.

        :type  name: str.
        :param name: The name of the attribute. The name has to be
                     unique as it is used as a key to store the node
                     object.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  plug: bool.
        :param plug: Whether or not this attribute can emit connections.

        :type  socket: bool.
        :param socket: Whether or not this attribute can receive
                       connections.

        :type  dataType: type.
        :param dataType: Type of the data represented by this attribute
                         in order to highlight attributes of the same
                         type while performing a connection.

        &#34;&#34;&#34;
        if name in self.attrs:
            print(&#39;An attribute with the same name already exists on this node : {0}&#39;.format(name))
            print(&#39;Attribute creation aborted !&#39;)
            return

        self.attrPreset = preset

        # Create a plug connection item.
        if plug:
            plugInst = PlugItem(parent=self,
                                attribute=name,
                                index=self.attrCount,
                                preset=preset,
                                dataType=dataType,
                                maxConnections=plugMaxConnections)

            self.plugs[name] = plugInst

        # Create a socket connection item.
        if socket:
            socketInst = SocketItem(parent=self,
                                    attribute=name,
                                    index=self.attrCount,
                                    preset=preset,
                                    dataType=dataType,
                                    maxConnections=socketMaxConnections)

            self.sockets[name] = socketInst

        self.attrCount += 1

        # Add the attribute based on its index.
        if index == -1 or index &gt; self.attrCount:
            self.attrs.append(name)
        else:
            self.attrs.insert(index, name)

        # Store attr data.
        self.attrsData[name] = {&#39;name&#39;: name,
                                &#39;socket&#39;: socket,
                                &#39;plug&#39;: plug,
                                &#39;preset&#39;: preset,
                                &#39;dataType&#39;: dataType,
                                &#39;plugMaxConnections&#39;: plugMaxConnections,
                                &#39;socketMaxConnections&#39;: socketMaxConnections
                                }

        # Update node height.
        self.update()

    def _deleteAttribute(self, index):
        &#34;&#34;&#34;
        Remove an attribute by reducing the node, removing the label
        and the connection items.

        :type  index: int.
        :param index: The index of the attribute in the node.

        &#34;&#34;&#34;
        name = self.attrs[index]

        # Remove socket and its connections.
        if name in self.sockets.keys():
            for connection in self.sockets[name].connections:
                connection._remove()

            self.scene().removeItem(self.sockets[name])
            self.sockets.pop(name)

        # Remove plug and its connections.
        if name in self.plugs.keys():
            for connection in self.plugs[name].connections:
                connection._remove()

            self.scene().removeItem(self.plugs[name])
            self.plugs.pop(name)

        # Reduce node height.
        if self.attrCount &gt; 0:
            self.attrCount -= 1

        # Remove attribute from node.
        if name in self.attrs:
            self.attrs.remove(name)

        self.update()

    def _remove(self):
        &#34;&#34;&#34;
        Remove this node instance from the scene.

        Make sure that all the connections to this node are also removed
        in the process

        &#34;&#34;&#34;
        self.scene().nodes.pop(self.name)

        # Remove all sockets connections.
        for socket in self.sockets.values():
            while len(socket.connections)&gt;0:
                socket.connections[0]._remove()

        # Remove all plugs connections.
        for plug in self.plugs.values():
            while len(plug.connections)&gt;0:
                plug.connections[0]._remove()

        # Remove node.
        scene = self.scene()
        scene.removeItem(self)
        scene.update()

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        rect = QtCore.QRect(0, 0, self.baseWidth, self.height)
        rect = QtCore.QRectF(rect)
        return rect

    def shape(self):
        &#34;&#34;&#34;
        The shape of the item.

        &#34;&#34;&#34;
        path = QtGui.QPainterPath()
        path.addRect(self.boundingRect())
        return path

    def paint(self, painter, option, widget):
        &#34;&#34;&#34;
        Paint the node and attributes.

        &#34;&#34;&#34;
        # Node base.
        painter.setBrush(self._brush)
        painter.setPen(self.pen)

        painter.drawRoundedRect(0, 0,
                                self.baseWidth,
                                self.height,
                                self.radius,
                                self.radius)

        # Node label.
        painter.setPen(self._textPen)
        painter.setFont(self._nodeTextFont)

        metrics = QtGui.QFontMetrics(painter.font())
        text_width = metrics.boundingRect(self.name).width() + 14
        text_height = metrics.boundingRect(self.name).height() + 14
        margin = (text_width - self.baseWidth) * 0.5
        textRect = QtCore.QRect(-margin,
                                -text_height,
                                text_width,
                                text_height)

        painter.drawText(textRect,
                         QtCore.Qt.AlignCenter,
                         self.name)


        # Attributes.
        offset = 0
        for attr in self.attrs:
            nodzInst = self.scene().views()[0]
            config = nodzInst.config

            # Attribute rect.
            rect = QtCore.QRect(self.border / 2,
                                self.baseHeight - self.radius + offset,
                                self.baseWidth - self.border,
                                self.attrHeight)



            attrData = self.attrsData[attr]
            name = attr

            preset = attrData[&#39;preset&#39;]


            # Attribute base.
            self._attrBrush.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;]))
            if self.alternate:
                self._attrBrushAlt.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;], True, config[&#39;alternate_value&#39;]))

            self._attrPen.setColor(utils._convertDataToColor([0, 0, 0, 0]))
            painter.setPen(self._attrPen)
            painter.setBrush(self._attrBrush)
            if (offset / self.attrHeight) % 2:
                painter.setBrush(self._attrBrushAlt)

            painter.drawRect(rect)

            # Attribute label.
            painter.setPen(utils._convertDataToColor(config[preset][&#39;text&#39;]))
            painter.setFont(self._attrTextFont)

            # Search non-connectable attributes.
            if nodzInst.drawingConnection:
                if self == nodzInst.currentHoveredNode:
                    if (attrData[&#39;dataType&#39;] != nodzInst.sourcepyqtSlot.dataType or
                        (nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;plug&#39; and attrData[&#39;socket&#39;] == False or
                         nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;socket&#39; and attrData[&#39;plug&#39;] == False)):
                        # Set non-connectable attributes color.
                        painter.setPen(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))

            textRect = QtCore.QRect(rect.left() + self.radius,
                                     rect.top(),
                                     rect.width() - 2*self.radius,
                                     rect.height())
            painter.drawText(textRect, QtCore.Qt.AlignVCenter, name)

            offset += self.attrHeight

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Keep the selected node on top of the others.

        &#34;&#34;&#34;
        nodes = self.scene().nodes
        for node in nodes.values():
            node.setZValue(1)

        for item in self.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(1)

        self.setZValue(2)

        super(NodeItem, self).mousePressEvent(event)

    def mouseDoubleClickEvent(self, event):
        &#34;&#34;&#34;
        Emit a pyqtSignal.

        &#34;&#34;&#34;
        super(NodeItem, self).mouseDoubleClickEvent(event)
        self.scene().parent().pyqtSignal_NodeDoubleClicked.emit(self.name)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        if self.scene().views()[0].gridVisToggle:
            if self.scene().views()[0].gridSnapToggle or self.scene().views()[0]._nodeSnap:
                gridSize = self.scene().gridSize

                currentPos = self.mapToScene(event.pos().x() - self.baseWidth / 2,
                                             event.pos().y() - self.height / 2)

                snap_x = (round(currentPos.x() / gridSize) * gridSize) - gridSize/4
                snap_y = (round(currentPos.y() / gridSize) * gridSize) - gridSize/4
                snap_pos = QtCore.QPointF(snap_x, snap_y)
                self.setPos(snap_pos)

                self.scene().updateScene()
            else:
                self.scene().updateScene()
                super(NodeItem, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        # Emit node moved pyqtSignal.
        self.scene().pyqtSignal_NodeMoved.emit(self.name, self.pos())
        super(NodeItem, self).mouseReleaseEvent(event)

    def hoverLeaveEvent(self, event):
        &#34;&#34;&#34;
        .

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]

        for item in nodzInst.scene().items():
            if isinstance(item, ConnectionItem):
                item.setZValue(0)

        super(NodeItem, self).hoverLeaveEvent(event)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>Increment the final height of the node every time an attribute
is created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34;
    Increment the final height of the node every time an attribute
    is created.

    &#34;&#34;&#34;
    if self.attrCount &gt; 0:
        return (self.baseHeight +
                self.attrHeight * self.attrCount +
                self.border +
                0.5 * self.radius)
    else:
        return self.baseHeight</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.pen"><code class="name">var <span class="ident">pen</span></code></dt>
<dd>
<div class="desc"><p>Return the pen based on the selection state of the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pen(self):
    &#34;&#34;&#34;
    Return the pen based on the selection state of the node.

    &#34;&#34;&#34;
    if self.isSelected():
        return self._penSel
    else:
        return self._pen</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding rect based on the width and height variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self):
    &#34;&#34;&#34;
    The bounding rect based on the width and height variables.

    &#34;&#34;&#34;
    rect = QtCore.QRect(0, 0, self.baseWidth, self.height)
    rect = QtCore.QRectF(rect)
    return rect</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.hoverLeaveEvent"><code class="name flex">
<span>def <span class="ident">hoverLeaveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hoverLeaveEvent(self, event):
    &#34;&#34;&#34;
    .

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]

    for item in nodzInst.scene().items():
        if isinstance(item, ConnectionItem):
            item.setZValue(0)

    super(NodeItem, self).hoverLeaveEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseDoubleClickEvent"><code class="name flex">
<span>def <span class="ident">mouseDoubleClickEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Emit a pyqtSignal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseDoubleClickEvent(self, event):
    &#34;&#34;&#34;
    Emit a pyqtSignal.

    &#34;&#34;&#34;
    super(NodeItem, self).mouseDoubleClickEvent(event)
    self.scene().parent().pyqtSignal_NodeDoubleClicked.emit(self.name)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    &#34;&#34;&#34;
    .

    &#34;&#34;&#34;
    if self.scene().views()[0].gridVisToggle:
        if self.scene().views()[0].gridSnapToggle or self.scene().views()[0]._nodeSnap:
            gridSize = self.scene().gridSize

            currentPos = self.mapToScene(event.pos().x() - self.baseWidth / 2,
                                         event.pos().y() - self.height / 2)

            snap_x = (round(currentPos.x() / gridSize) * gridSize) - gridSize/4
            snap_y = (round(currentPos.y() / gridSize) * gridSize) - gridSize/4
            snap_pos = QtCore.QPointF(snap_x, snap_y)
            self.setPos(snap_pos)

            self.scene().updateScene()
        else:
            self.scene().updateScene()
            super(NodeItem, self).mouseMoveEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep the selected node on top of the others.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    &#34;&#34;&#34;
    Keep the selected node on top of the others.

    &#34;&#34;&#34;
    nodes = self.scene().nodes
    for node in nodes.values():
        node.setZValue(1)

    for item in self.scene().items():
        if isinstance(item, ConnectionItem):
            item.setZValue(1)

    self.setZValue(2)

    super(NodeItem, self).mousePressEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, event):
    &#34;&#34;&#34;
    .

    &#34;&#34;&#34;
    # Emit node moved pyqtSignal.
    self.scene().pyqtSignal_NodeMoved.emit(self.name, self.pos())
    super(NodeItem, self).mouseReleaseEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.paint"><code class="name flex">
<span>def <span class="ident">paint</span></span>(<span>self, painter, option, widget)</span>
</code></dt>
<dd>
<div class="desc"><p>Paint the node and attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint(self, painter, option, widget):
    &#34;&#34;&#34;
    Paint the node and attributes.

    &#34;&#34;&#34;
    # Node base.
    painter.setBrush(self._brush)
    painter.setPen(self.pen)

    painter.drawRoundedRect(0, 0,
                            self.baseWidth,
                            self.height,
                            self.radius,
                            self.radius)

    # Node label.
    painter.setPen(self._textPen)
    painter.setFont(self._nodeTextFont)

    metrics = QtGui.QFontMetrics(painter.font())
    text_width = metrics.boundingRect(self.name).width() + 14
    text_height = metrics.boundingRect(self.name).height() + 14
    margin = (text_width - self.baseWidth) * 0.5
    textRect = QtCore.QRect(-margin,
                            -text_height,
                            text_width,
                            text_height)

    painter.drawText(textRect,
                     QtCore.Qt.AlignCenter,
                     self.name)


    # Attributes.
    offset = 0
    for attr in self.attrs:
        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        # Attribute rect.
        rect = QtCore.QRect(self.border / 2,
                            self.baseHeight - self.radius + offset,
                            self.baseWidth - self.border,
                            self.attrHeight)



        attrData = self.attrsData[attr]
        name = attr

        preset = attrData[&#39;preset&#39;]


        # Attribute base.
        self._attrBrush.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;]))
        if self.alternate:
            self._attrBrushAlt.setColor(utils._convertDataToColor(config[preset][&#39;bg&#39;], True, config[&#39;alternate_value&#39;]))

        self._attrPen.setColor(utils._convertDataToColor([0, 0, 0, 0]))
        painter.setPen(self._attrPen)
        painter.setBrush(self._attrBrush)
        if (offset / self.attrHeight) % 2:
            painter.setBrush(self._attrBrushAlt)

        painter.drawRect(rect)

        # Attribute label.
        painter.setPen(utils._convertDataToColor(config[preset][&#39;text&#39;]))
        painter.setFont(self._attrTextFont)

        # Search non-connectable attributes.
        if nodzInst.drawingConnection:
            if self == nodzInst.currentHoveredNode:
                if (attrData[&#39;dataType&#39;] != nodzInst.sourcepyqtSlot.dataType or
                    (nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;plug&#39; and attrData[&#39;socket&#39;] == False or
                     nodzInst.sourcepyqtSlot.pyqtSlotType == &#39;socket&#39; and attrData[&#39;plug&#39;] == False)):
                    # Set non-connectable attributes color.
                    painter.setPen(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))

        textRect = QtCore.QRect(rect.left() + self.radius,
                                 rect.top(),
                                 rect.width() - 2*self.radius,
                                 rect.height())
        painter.drawText(textRect, QtCore.Qt.AlignVCenter, name)

        offset += self.attrHeight</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The shape of the item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape(self):
    &#34;&#34;&#34;
    The shape of the item.

    &#34;&#34;&#34;
    path = QtGui.QPainterPath()
    path.addRect(self.boundingRect())
    return path</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene"><code class="flex name class">
<span>class <span class="ident">NodeScene</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>The scene displaying all the nodes.</p>
<p>Initialize the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeScene(QtWidgets.QGraphicsScene):

    &#34;&#34;&#34;
    The scene displaying all the nodes.

    &#34;&#34;&#34;
    pyqtSignal_NodeMoved = QtCore.pyqtSignal(str, object)

    def __init__(self, parent):
        &#34;&#34;&#34;
        Initialize the class.

        &#34;&#34;&#34;
        super(NodeScene, self).__init__(parent)

        # General.
        self.gridSize = parent.config[&#39;grid_size&#39;]

        # Nodes storage.
        self.nodes = dict()

    def dragEnterEvent(self, event):
        &#34;&#34;&#34;
        Make the dragging of nodes into the scene possible.

        &#34;&#34;&#34;
        event.setDropAction(QtCore.Qt.MoveAction)
        event.accept()

    def dragMoveEvent(self, event):
        &#34;&#34;&#34;
        Make the dragging of nodes into the scene possible.

        &#34;&#34;&#34;
        event.setDropAction(QtCore.Qt.MoveAction)
        event.accept()

    def dropEvent(self, event):
        &#34;&#34;&#34;
        Create a node from the dropped item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        self.pyqtSignal_Dropped.emit(event.scenePos())

        event.accept()

    def drawBackground(self, painter, rect):
        &#34;&#34;&#34;
        Draw a grid in the background.

        &#34;&#34;&#34;
        config = self.parent().config

        self._brush = QtGui.QBrush()
        self._brush.setStyle(QtCore.Qt.SolidPattern)
        self._brush.setColor(utils._convertDataToColor(config[&#39;bg_color&#39;]))

        painter.fillRect(rect, self._brush)

        if self.views()[0].gridVisToggle:
            leftLine = rect.left() - rect.left() % self.gridSize
            topLine = rect.top() - rect.top() % self.gridSize
            lines = list()

            i = int(leftLine)
            while i &lt; int(rect.right()):
                lines.append(QtCore.QLineF(i, rect.top(), i, rect.bottom()))
                i += self.gridSize

            u = int(topLine)
            while u &lt; int(rect.bottom()):
                lines.append(QtCore.QLineF(rect.left(), u, rect.right(), u))
                u += self.gridSize

            self.pen = QtGui.QPen()
            self.pen.setColor(utils._convertDataToColor(config[&#39;grid_color&#39;]))
            self.pen.setWidth(0)
            painter.setPen(self.pen)
            painter.drawLines(lines)

    def updateScene(self):
        &#34;&#34;&#34;
        Update the connections position.

        &#34;&#34;&#34;
        for connection in [i for i in self.items() if isinstance(i, ConnectionItem)]:
            connection.target_point = connection.target.center()
            connection.source_point = connection.source.center()
            connection.updatePath()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsScene</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragEnterEvent"><code class="name flex">
<span>def <span class="ident">dragEnterEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the dragging of nodes into the scene possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dragEnterEvent(self, event):
    &#34;&#34;&#34;
    Make the dragging of nodes into the scene possible.

    &#34;&#34;&#34;
    event.setDropAction(QtCore.Qt.MoveAction)
    event.accept()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragMoveEvent"><code class="name flex">
<span>def <span class="ident">dragMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the dragging of nodes into the scene possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dragMoveEvent(self, event):
    &#34;&#34;&#34;
    Make the dragging of nodes into the scene possible.

    &#34;&#34;&#34;
    event.setDropAction(QtCore.Qt.MoveAction)
    event.accept()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.drawBackground"><code class="name flex">
<span>def <span class="ident">drawBackground</span></span>(<span>self, painter, rect)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a grid in the background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawBackground(self, painter, rect):
    &#34;&#34;&#34;
    Draw a grid in the background.

    &#34;&#34;&#34;
    config = self.parent().config

    self._brush = QtGui.QBrush()
    self._brush.setStyle(QtCore.Qt.SolidPattern)
    self._brush.setColor(utils._convertDataToColor(config[&#39;bg_color&#39;]))

    painter.fillRect(rect, self._brush)

    if self.views()[0].gridVisToggle:
        leftLine = rect.left() - rect.left() % self.gridSize
        topLine = rect.top() - rect.top() % self.gridSize
        lines = list()

        i = int(leftLine)
        while i &lt; int(rect.right()):
            lines.append(QtCore.QLineF(i, rect.top(), i, rect.bottom()))
            i += self.gridSize

        u = int(topLine)
        while u &lt; int(rect.bottom()):
            lines.append(QtCore.QLineF(rect.left(), u, rect.right(), u))
            u += self.gridSize

        self.pen = QtGui.QPen()
        self.pen.setColor(utils._convertDataToColor(config[&#39;grid_color&#39;]))
        self.pen.setWidth(0)
        painter.setPen(self.pen)
        painter.drawLines(lines)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dropEvent"><code class="name flex">
<span>def <span class="ident">dropEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a node from the dropped item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dropEvent(self, event):
    &#34;&#34;&#34;
    Create a node from the dropped item.

    &#34;&#34;&#34;
    # Emit pyqtSignal.
    self.pyqtSignal_Dropped.emit(event.scenePos())

    event.accept()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.pyqtSignal_NodeMoved"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeMoved</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.updateScene"><code class="name flex">
<span>def <span class="ident">updateScene</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the connections position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateScene(self):
    &#34;&#34;&#34;
    Update the connections position.

    &#34;&#34;&#34;
    for connection in [i for i in self.items() if isinstance(i, ConnectionItem)]:
        connection.target_point = connection.target.center()
        connection.source_point = connection.source.center()
        connection.updatePath()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz"><code class="flex name class">
<span>class <span class="ident">Nodz</span></span>
<span>(</span><span>parent, configPath='/home/marcin648/python/WizualizacjaAlgorytmow/WizualizacjaAlgorytmow/Resources/nodz.json')</span>
</code></dt>
<dd>
<div class="desc"><p>The main view for the node graph representation.</p>
<p>The node view implements a state pattern to control all the
different user interactions.</p>
<p>Initialize the graphics view.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nodz(QtWidgets.QGraphicsView):

    &#34;&#34;&#34;
    The main view for the node graph representation.

    The node view implements a state pattern to control all the
    different user interactions.

    &#34;&#34;&#34;

    pyqtSignal_NodeCreated = QtCore.pyqtSignal(object)
    pyqtSignal_NodeDeleted = QtCore.pyqtSignal(object)
    pyqtSignal_NodeEdited = QtCore.pyqtSignal(object, object)
    pyqtSignal_NodeSelected = QtCore.pyqtSignal(object)
    pyqtSignal_NodeMoved = QtCore.pyqtSignal(str, object)
    pyqtSignal_NodeDoubleClicked = QtCore.pyqtSignal(str)

    pyqtSignal_AttrCreated = QtCore.pyqtSignal(object, object)
    pyqtSignal_AttrDeleted = QtCore.pyqtSignal(object, object)
    pyqtSignal_AttrEdited = QtCore.pyqtSignal(object, object, object)

    pyqtSignal_PlugConnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_PlugDisconnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_SocketConnected = QtCore.pyqtSignal(object, object, object, object)
    pyqtSignal_SocketDisconnected = QtCore.pyqtSignal(object, object, object, object)

    pyqtSignal_GraphSaved = QtCore.pyqtSignal()
    pyqtSignal_GraphLoaded = QtCore.pyqtSignal()
    pyqtSignal_GraphCleared = QtCore.pyqtSignal()
    pyqtSignal_GraphEvaluated = QtCore.pyqtSignal()

    pyqtSignal_KeyPressed = QtCore.pyqtSignal(object)
    pyqtSignal_Dropped = QtCore.pyqtSignal()

    def __init__(self, parent, configPath=defaultConfigPath):
        &#34;&#34;&#34;
        Initialize the graphics view.

        &#34;&#34;&#34;
        super(Nodz, self).__init__(parent)

        # Load nodz configuration.
        self.loadConfig(configPath)

        # General data.
        self.gridVisToggle = True
        self.gridSnapToggle = False
        self._nodeSnap = False
        self.selectedNodes = []

        # Connections data.
        self.drawingConnection = False
        self.currentHoveredNode = None
        self.sourcepyqtSlot = None

        # Display options.
        self.currentState = &#39;DEFAULT&#39;
        self.pressedKeys = list()

    def wheelEvent(self, event):
        &#34;&#34;&#34;
        Zoom in the view with the mouse wheel.

        &#34;&#34;&#34;
        self.currentState = &#39;ZOOM_VIEW&#39;
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        inFactor = 1.15
        outFactor = 1 / inFactor

        if event.angleDelta().y() &gt; 0:
            zoomFactor = inFactor
        else:
            zoomFactor = outFactor

        self.scale(zoomFactor, zoomFactor)
        self.currentState = &#39;DEFAULT&#39;

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Initialize tablet zoom, drag canvas and the selection.

        &#34;&#34;&#34;
        # Tablet zoom
        if (event.button() == QtCore.Qt.RightButton and
            event.modifiers() == QtCore.Qt.AltModifier):
            self.currentState = &#39;ZOOM_VIEW&#39;
            self.initMousePos = event.pos()
            self.zoomInitialPos = event.pos()
            self.initMouse = QtGui.QCursor.pos()
            self.setInteractive(False)


        # Drag view
        elif (event.button() == QtCore.Qt.MiddleButton and
              event.modifiers() == QtCore.Qt.AltModifier):
            self.currentState = &#39;DRAG_VIEW&#39;
            self.prevPos = event.pos()
            self.setCursor(QtCore.Qt.ClosedHandCursor)
            self.setInteractive(False)


        # Rubber band selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.NoModifier and
              self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is None):
            self.currentState = &#39;SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Drag Item
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.NoModifier and
              self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is not None):
            self.currentState = &#39;DRAG_ITEM&#39;
            self.setInteractive(True)


        # Add selection
        elif (event.button() == QtCore.Qt.LeftButton and
              QtCore.Qt.Key_Shift in self.pressedKeys and
              QtCore.Qt.Key_Control in self.pressedKeys):
            self.currentState = &#39;ADD_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Subtract selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.ControlModifier):
            self.currentState = &#39;SUBTRACT_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        # Toggle selection
        elif (event.button() == QtCore.Qt.LeftButton and
              event.modifiers() == QtCore.Qt.ShiftModifier):
            self.currentState = &#39;TOGGLE_SELECTION&#39;
            self._initRubberband(event.pos())
            self.setInteractive(False)


        else:
            self.currentState = &#39;DEFAULT&#39;

        super(Nodz, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Update tablet zoom, canvas dragging and selection.

        &#34;&#34;&#34;
        # Zoom.
        if self.currentState == &#39;ZOOM_VIEW&#39;:
            offset = self.zoomInitialPos.x() - event.pos().x()

            if offset &gt; self.previousMouseOffset:
                self.previousMouseOffset = offset
                self.zoomDirection = -1
                self.zoomIncr -= 1

            elif offset == self.previousMouseOffset:
                self.previousMouseOffset = offset
                if self.zoomDirection == -1:
                    self.zoomDirection = -1
                else:
                    self.zoomDirection = 1

            else:
                self.previousMouseOffset = offset
                self.zoomDirection = 1
                self.zoomIncr += 1

            if self.zoomDirection == 1:
                zoomFactor = 1.03
            else:
                zoomFactor = 1 / 1.03

            # Perform zoom and re-center on initial click position.
            pBefore = self.mapToScene(self.initMousePos)
            self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorViewCenter)
            self.scale(zoomFactor, zoomFactor)
            pAfter = self.mapToScene(self.initMousePos)
            diff = pAfter - pBefore

            self.setTransformationAnchor(QtWidgets.QGraphicsView.NoAnchor)
            self.translate(diff.x(), diff.y())
            pass

        # Drag canvas.
        elif self.currentState == &#39;DRAG_VIEW&#39;:
            offset = self.prevPos - event.pos()
            self.prevPos = event.pos()
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() + offset.y())
            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() + offset.x())

        # RuberBand selection.
        elif (self.currentState == &#39;SELECTION&#39; or
              self.currentState == &#39;ADD_SELECTION&#39; or
              self.currentState == &#39;SUBTRACT_SELECTION&#39; or
              self.currentState == &#39;TOGGLE_SELECTION&#39;):
            self.rubberband.setGeometry(QtCore.QRect(self.origin, event.pos()).normalized())

        super(Nodz, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Apply tablet zoom, dragging and selection.

        &#34;&#34;&#34;
        # Zoom the View.
        if self.currentState == &#39;.ZOOM_VIEW&#39;:
            self.offset = 0
            self.zoomDirection = 0
            self.zoomIncr = 0
            self.setInteractive(True)


        # Drag View.
        elif self.currentState == &#39;DRAG_VIEW&#39;:
            self.setCursor(QtCore.Qt.ArrowCursor)
            self.setInteractive(True)


        # Selection.
        elif self.currentState == &#39;SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            self.scene().setSelectionArea(painterPath)


        # Add Selection.
        elif self.currentState == &#39;ADD_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                item.setSelected(True)


        # Subtract Selection.
        elif self.currentState == &#39;SUBTRACT_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                item.setSelected(False)


        # Toggle Selection
        elif self.currentState == &#39;TOGGLE_SELECTION&#39;:
            self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                     event.pos()).normalized())
            painterPath = self._releaseRubberband()
            self.setInteractive(True)
            for item in self.scene().items(painterPath):
                if item.isSelected():
                    item.setSelected(False)
                else:
                    item.setSelected(True)

        self.currentState = &#39;DEFAULT&#39;

        super(Nodz, self).mouseReleaseEvent(event)

    def keyPressEvent(self, event):
        &#34;&#34;&#34;
        Save pressed key and apply shortcuts.

        Shortcuts are:
        DEL - Delete the selected nodes
        F - Focus view on the selection

        &#34;&#34;&#34;
        if event.key() not in self.pressedKeys:
            self.pressedKeys.append(event.key())

        if event.key() in (QtCore.Qt.Key_Delete, QtCore.Qt.Key_Backspace):
            self._deleteSelectedNodes()

        if event.key() == QtCore.Qt.Key_F:
            self._focus()

        if event.key() == QtCore.Qt.Key_S:
            self._nodeSnap = True

        # Emit pyqtSignal.
        self.pyqtSignal_KeyPressed.emit(event.key())

    def keyReleaseEvent(self, event):
        &#34;&#34;&#34;
        Clear the key from the pressed key list.

        &#34;&#34;&#34;
        if event.key() == QtCore.Qt.Key_S:
            self._nodeSnap = False

        if event.key() in self.pressedKeys:
            self.pressedKeys.remove(event.key())

    def _initRubberband(self, position):
        &#34;&#34;&#34;
        Initialize the rubber band at the given position.

        &#34;&#34;&#34;
        self.rubberBandStart = position
        self.origin = position
        self.rubberband.setGeometry(QtCore.QRect(self.origin, QtCore.QSize()))
        self.rubberband.show()

    def _releaseRubberband(self):
        &#34;&#34;&#34;
        Hide the rubber band and return the path.

        &#34;&#34;&#34;
        painterPath = QtGui.QPainterPath()
        rect = self.mapToScene(self.rubberband.geometry())
        painterPath.addPolygon(rect)
        self.rubberband.hide()
        return painterPath

    def _focus(self):
        &#34;&#34;&#34;
        Center on selected nodes or all of them if no active selection.

        &#34;&#34;&#34;
        if self.scene().selectedItems():
            itemsArea = self._getSelectionBoundingbox()
            self.fitInView(itemsArea, QtCore.Qt.KeepAspectRatio)
        else:
            itemsArea = self.scene().itemsBoundingRect()
            self.fitInView(itemsArea, QtCore.Qt.KeepAspectRatio)

    def _getSelectionBoundingbox(self):
        &#34;&#34;&#34;
        Return the bounding box of the selection.

        &#34;&#34;&#34;
        bbx_min = None
        bbx_max = None
        bby_min = None
        bby_max = None
        bbw = 0
        bbh = 0
        for item in self.scene().selectedItems():
            pos = item.scenePos()
            x = pos.x()
            y = pos.y()
            w = x + item.boundingRect().width()
            h = y + item.boundingRect().height()

            # bbx min
            if bbx_min is None:
                bbx_min = x
            elif x &lt; bbx_min:
                bbx_min = x
            # end if

            # bbx max
            if bbx_max is None:
                bbx_max = w
            elif w &gt; bbx_max:
                bbx_max = w
            # end if

            # bby min
            if bby_min is None:
                bby_min = y
            elif y &lt; bby_min:
                bby_min = y
            # end if

            # bby max
            if bby_max is None:
                bby_max = h
            elif h &gt; bby_max:
                bby_max = h
            # end if
        # end if
        bbw = bbx_max - bbx_min
        bbh = bby_max - bby_min
        return QtCore.QRectF(QtCore.QRect(bbx_min, bby_min, bbw, bbh))

    def _deleteSelectedNodes(self):
        &#34;&#34;&#34;
        Delete selected nodes.

        &#34;&#34;&#34;
        selected_nodes = list()
        for node in self.scene().selectedItems():
            selected_nodes.append(node.name)
            node._remove()

        # Emit pyqtSignal.
        self.pyqtSignal_NodeDeleted.emit(selected_nodes)

    def _returnSelection(self):
        &#34;&#34;&#34;
        Wrapper to return selected items.

        &#34;&#34;&#34;
        selected_nodes = list()
        if self.scene().selectedItems():
            for node in self.scene().selectedItems():
                selected_nodes.append(node.name)

        # Emit pyqtSignal.
        self.pyqtSignal_NodeSelected.emit(selected_nodes)


    ##################################################################
    # API
    ##################################################################

    def loadConfig(self, filePath):
        &#34;&#34;&#34;
        Set a specific configuration for this instance of Nodz.

        :type  filePath: str.
        :param filePath: The path to the config file that you want to
                         use.

        &#34;&#34;&#34;
        self.config = utils._loadConfig(filePath)

    def initialize(self):
        &#34;&#34;&#34;
        Setup the view&#39;s behavior.

        &#34;&#34;&#34;
        # Setup view.
        config = self.config
        self.setRenderHint(QtGui.QPainter.Antialiasing, config[&#39;antialiasing&#39;])
        self.setRenderHint(QtGui.QPainter.TextAntialiasing, config[&#39;antialiasing&#39;])
        self.setRenderHint(QtGui.QPainter.HighQualityAntialiasing, config[&#39;antialiasing_boost&#39;])
        self.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, config[&#39;smooth_pixmap&#39;])
        self.setRenderHint(QtGui.QPainter.NonCosmeticDefaultPen, True)
        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.rubberband = QtWidgets.QRubberBand(QtWidgets.QRubberBand.Rectangle, self)

        # Setup scene.
        scene = NodeScene(self)
        sceneWidth = config[&#39;scene_width&#39;]
        sceneHeight = config[&#39;scene_height&#39;]
        scene.setSceneRect(0, 0, sceneWidth, sceneHeight)
        self.setScene(scene)
        # Connect scene node moved pyqtSignal
        scene.pyqtSignal_NodeMoved.connect(self.pyqtSignal_NodeMoved)

        # Tablet zoom.
        self.previousMouseOffset = 0
        self.zoomDirection = 0
        self.zoomIncr = 0

        # Connect pyqtSignals.
        self.scene().selectionChanged.connect(self._returnSelection)


    # NODES
    def createNode(self, name=&#39;default&#39;, preset=&#39;node_default&#39;, position=None, alternate=True):
        &#34;&#34;&#34;
        Create a new node with a given name, position and color.

        :type  name: str.
        :param name: The name of the node. The name has to be unique
                     as it is used as a key to store the node object.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  position: QtCore.QPoint.
        :param position: The position of the node once created. If None,
                         it will be created at the center of the scene.

        :type  alternate: bool.
        :param alternate: The attribute color alternate state, if True,
                          every 2 attribute the color will be slightly
                          darker.

        :return : The created node

        &#34;&#34;&#34;
        # Check for name clashes
        if name in self.scene().nodes.keys():
            print(&#39;A node with the same name already exists : {0}&#39;.format(name))
            print(&#39;Node creation aborted !&#39;)
            return
        else:
            nodeItem = NodeItem(name=name, alternate=alternate, preset=preset,
                                config=self.config)

            # Store node in scene.
            self.scene().nodes[name] = nodeItem

            if not position:
                # Get the center of the view.
                position = self.mapToScene(self.viewport().rect().center())

            # Set node position.
            self.scene().addItem(nodeItem)
            nodeItem.setPos(position - nodeItem.nodeCenter)

            # Emit pyqtSignal.
            self.pyqtSignal_NodeCreated.emit(name)

            return nodeItem

    def deleteNode(self, node):
        &#34;&#34;&#34;
        Delete the specified node from the view.

        :type  node: class.
        :param node: The node instance that you want to delete.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Node deletion aborted !&#39;)
            return

        if node in self.scene().nodes.values():
            nodeName = node.name
            node._remove()

            # Emit pyqtSignal.
            self.pyqtSignal_NodeDeleted.emit([nodeName])

    def editNode(self, node, newName=None):
        &#34;&#34;&#34;
        Rename an existing node.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  newName: str.
        :param newName: The new name for the given node.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Node edition aborted !&#39;)
            return

        oldName = node.name

        if newName != None:
            # Check for name clashes
            if newName in self.scene().nodes.keys():
                print(&#39;A node with the same name already exists : {0}&#39;.format(newName))
                print(&#39;Node edition aborted !&#39;)
                return
            else:
                node.name = newName

        # Replace node data.
        self.scene().nodes[newName] = self.scene().nodes[oldName]
        self.scene().nodes.pop(oldName)

        # Store new node name in the connections
        if node.sockets:
            for socket in node.sockets.values():
                for connection in socket.connections:
                    connection.socketNode = newName

        if node.plugs:
            for plug in node.plugs.values():
                for connection in plug.connections:
                    connection.plugNode = newName

        node.update()

        # Emit pyqtSignal.
        self.pyqtSignal_NodeEdited.emit(oldName, newName)


    # ATTRS
    def createAttribute(self, node, name=&#39;default&#39;, index=-1, preset=&#39;attr_default&#39;, plug=True, socket=True, dataType=None, plugMaxConnections=-1, socketMaxConnections=1):
        &#34;&#34;&#34;
        Create a new attribute with a given name.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  name: str.
        :param name: The name of the attribute. The name has to be
                     unique as it is used as a key to store the node
                     object.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :type  plug: bool.
        :param plug: Whether or not this attribute can emit connections.

        :type  socket: bool.
        :param socket: Whether or not this attribute can receive
                       connections.

        :type  dataType: type.
        :param dataType: Type of the data represented by this attribute
                         in order to highlight attributes of the same
                         type while performing a connection.

        :type  plugMaxConnections: int.
        :param plugMaxConnections: The maximum connections that the plug can have (-1 for infinite).

        :type  socketMaxConnections: int.
        :param socketMaxConnections: The maximum connections that the socket can have (-1 for infinite).

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute creation aborted !&#39;)
            return

        if name in node.attrs:
            print(&#39;An attribute with the same name already exists : {0}&#39;.format(name))
            print(&#39;Attribute creation aborted !&#39;)
            return

        node._createAttribute(name=name, index=index, preset=preset, plug=plug, socket=socket, dataType=dataType, plugMaxConnections=plugMaxConnections, socketMaxConnections=socketMaxConnections)

        # Emit pyqtSignal.
        self.pyqtSignal_AttrCreated.emit(node.name, index)

    def deleteAttribute(self, node, index):
        &#34;&#34;&#34;
        Delete the specified attribute.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  index: int.
        :param index: The index of the attribute in the node.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute deletion aborted !&#39;)
            return

        node._deleteAttribute(index)

        # Emit pyqtSignal.
        self.pyqtSignal_AttrDeleted.emit(node.name, index)

    def editAttribute(self, node, index, newName=None, newIndex=None):
        &#34;&#34;&#34;
        Edit the specified attribute.

        :type  node: class.
        :param node: The node instance that you want to delete.

        :type  index: int.
        :param index: The index of the attribute in the node.

        :type  newName: str.
        :param newName: The new name for the given attribute.

        :type  newIndex: int.
        :param newIndex: The index for the given attribute.

        &#34;&#34;&#34;
        if not node in self.scene().nodes.values():
            print(&#39;Node object does not exist !&#39;)
            print(&#39;Attribute creation aborted !&#39;)
            return

        if newName != None:
            if newName in node.attrs:
                print(&#39;An attribute with the same name already exists : {0}&#39;.format(newName))
                print(&#39;Attribute edition aborted !&#39;)
                return
            else:
                oldName = node.attrs[index]

            # Rename in the pyqtSlot item(s).
            if node.attrsData[oldName][&#39;plug&#39;]:
                node.plugs[oldName].attribute = newName
                node.plugs[newName] = node.plugs[oldName]
                node.plugs.pop(oldName)
                for connection in node.plugs[newName].connections:
                    connection.plugAttr = newName

            if node.attrsData[oldName][&#39;socket&#39;]:
                node.sockets[oldName].attribute = newName
                node.sockets[newName] = node.sockets[oldName]
                node.sockets.pop(oldName)
                for connection in node.sockets[newName].connections:
                    connection.socketAttr = newName

            # Replace attribute data.
            node.attrsData[oldName][&#39;name&#39;] = newName
            node.attrsData[newName] = node.attrsData[oldName]
            node.attrsData.pop(oldName)
            node.attrs[index] = newName

        if isinstance(newIndex, int):
            attrName = node.attrs[index]

            utils._swapListIndices(node.attrs, index, newIndex)

            # Refresh connections.
            for plug in node.plugs.values():
                plug.update()
                if plug.connections:
                    for connection in plug.connections:
                        if isinstance(connection.source, PlugItem):
                            connection.source = plug
                            connection.source_point = plug.center()
                        else:
                            connection.target = plug
                            connection.target_point = plug.center()
                        if newName:
                            connection.plugAttr = newName
                        connection.updatePath()

            for socket in node.sockets.values():
                socket.update()
                if socket.connections:
                    for connection in socket.connections:
                        if isinstance(connection.source, SocketItem):
                            connection.source = socket
                            connection.source_point = socket.center()
                        else:
                            connection.target = socket
                            connection.target_point = socket.center()
                        if newName:
                            connection.socketAttr = newName
                        connection.updatePath()

            self.scene().update()

        node.update()

        # Emit pyqtSignal.
        if newIndex:
            self.pyqtSignal_AttrEdited.emit(node.name, index, newIndex)
        else:
            self.pyqtSignal_AttrEdited.emit(node.name, index, index)


    # GRAPH
    def saveGraph(self, filePath=&#39;path&#39;):
        &#34;&#34;&#34;
        Get all the current graph infos and store them in a .json file
        at the given location.

        :type  filePath: str.
        :param filePath: The path where you want to save your graph at.

        &#34;&#34;&#34;
        data = dict()

        # Store nodes data.
        data[&#39;NODES&#39;] = dict()

        nodes = self.scene().nodes.keys()
        for node in nodes:
            nodeInst = self.scene().nodes[node]
            preset = nodeInst.nodePreset
            nodeAlternate = nodeInst.alternate

            data[&#39;NODES&#39;][node] = {&#39;preset&#39;: preset,
                                   &#39;position&#39;: [nodeInst.pos().x(), nodeInst.pos().y()],
                                   &#39;alternate&#39;: nodeAlternate,
                                   &#39;attributes&#39;: []}

            attrs = nodeInst.attrs
            for attr in attrs:
                attrData = nodeInst.attrsData[attr]

                # serialize dataType if needed.
                if isinstance(attrData[&#39;dataType&#39;], type):
                    attrData[&#39;dataType&#39;] = str(attrData[&#39;dataType&#39;])

                data[&#39;NODES&#39;][node][&#39;attributes&#39;].append(attrData)


        # Store connections data.
        data[&#39;CONNECTIONS&#39;] = self.evaluateGraph()


        # Save data.
        try:
            utils._saveData(filePath=filePath, data=data)
        except:
            print(&#39;Invalid path : {0}&#39;.format(filePath))
            print(&#39;Save aborted !&#39;)
            return False

        # Emit pyqtSignal.
        self.pyqtSignal_GraphSaved.emit()

    def loadGraph(self, filePath=&#39;path&#39;):
        &#34;&#34;&#34;
        Get all the stored info from the .json file at the given location
        and recreate the graph as saved.

        :type  filePath: str.
        :param filePath: The path where you want to load your graph from.

        &#34;&#34;&#34;
        # Load data.
        if os.path.exists(filePath):
            data = utils._loadData(filePath=filePath)
        else:
            print(&#39;Invalid path : {0}&#39;.format(filePath))
            print(&#39;Load aborted !&#39;)
            return False

        # Apply nodes data.
        nodesData = data[&#39;NODES&#39;]
        nodesName = nodesData.keys()

        for name in nodesName:
            preset = nodesData[name][&#39;preset&#39;]
            position = nodesData[name][&#39;position&#39;]
            position = QtCore.QPointF(position[0], position[1])
            alternate = nodesData[name][&#39;alternate&#39;]

            node = self.createNode(name=name,
                                   preset=preset,
                                   position=position,
                                   alternate=alternate)

            # Apply attributes data.
            attrsData = nodesData[name][&#39;attributes&#39;]

            for attrData in attrsData:
                index = attrsData.index(attrData)
                name = attrData[&#39;name&#39;]
                plug = attrData[&#39;plug&#39;]
                socket = attrData[&#39;socket&#39;]
                preset = attrData[&#39;preset&#39;]
                dataType = attrData[&#39;dataType&#39;]
                plugMaxConnections = attrData[&#39;plugMaxConnections&#39;]
                socketMaxConnections = attrData[&#39;socketMaxConnections&#39;]

                # un-serialize data type if needed
                if (isinstance(dataType, str) and dataType.find(&#39;&lt;&#39;) == 0):
                    dataType = eval(str(dataType.split(&#39;\&#39;&#39;)[1]))

                self.createAttribute(node=node,
                                     name=name,
                                     index=index,
                                     preset=preset,
                                     plug=plug,
                                     socket=socket,
                                     dataType=dataType,
                                     plugMaxConnections=plugMaxConnections,
                                     socketMaxConnections=socketMaxConnections
                                     )

        # Apply connections data.
        connectionsData = data[&#39;CONNECTIONS&#39;]

        for connection in connectionsData:
            source = connection[0]
            sourceNode = source.split(&#39;.&#39;)[0]
            sourceAttr = source.split(&#39;.&#39;)[1]

            target = connection[1]
            targetNode = target.split(&#39;.&#39;)[0]
            targetAttr = target.split(&#39;.&#39;)[1]

            self.createConnection(sourceNode, sourceAttr,
                                  targetNode, targetAttr)

        self.scene().update()

        # Emit pyqtSignal.
        self.pyqtSignal_GraphLoaded.emit()

    def createConnection(self, sourceNode, sourceAttr, targetNode, targetAttr):
        &#34;&#34;&#34;
        Create a manual connection.

        :type  sourceNode: str.
        :param sourceNode: Node that emits the connection.

        :type  sourceAttr: str.
        :param sourceAttr: Attribute that emits the connection.

        :type  targetNode: str.
        :param targetNode: Node that receives the connection.

        :type  targetAttr: str.
        :param targetAttr: Attribute that receives the connection.

        &#34;&#34;&#34;
        plug = self.scene().nodes[sourceNode].plugs[sourceAttr]
        socket = self.scene().nodes[targetNode].sockets[targetAttr]

        connection = ConnectionItem(plug.center(), socket.center(), plug, socket)

        connection.plugNode = plug.parentItem().name
        connection.plugAttr = plug.attribute
        connection.socketNode = socket.parentItem().name
        connection.socketAttr = socket.attribute

        plug.connect(socket, connection)
        socket.connect(plug, connection)

        connection.updatePath()

        self.scene().addItem(connection)

        return connection

    def evaluateGraph(self):
        &#34;&#34;&#34;
        Create a list of connection tuples.
        [(&#34;sourceNode.attribute&#34;, &#34;TargetNode.attribute&#34;), ...]

        &#34;&#34;&#34;
        scene = self.scene()

        data = list()

        for item in scene.items():
            if isinstance(item, ConnectionItem):
                connection = item

                data.append(connection._outputConnectionData())

        # Emit pyqtSignal
        self.pyqtSignal_GraphEvaluated.emit()

        return data

    def clearGraph(self):
        &#34;&#34;&#34;
        Clear the graph.

        &#34;&#34;&#34;
        self.scene().clear()
        self.scene().nodes = dict()

        # Emit pyqtSignal.
        self.pyqtSignal_GraphCleared.emit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.clearGraph"><code class="name flex">
<span>def <span class="ident">clearGraph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearGraph(self):
    &#34;&#34;&#34;
    Clear the graph.

    &#34;&#34;&#34;
    self.scene().clear()
    self.scene().nodes = dict()

    # Emit pyqtSignal.
    self.pyqtSignal_GraphCleared.emit()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createAttribute"><code class="name flex">
<span>def <span class="ident">createAttribute</span></span>(<span>self, node, name='default', index=-1, preset='attr_default', plug=True, socket=True, dataType=None, plugMaxConnections=-1, socketMaxConnections=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new attribute with a given name.</p>
<p>:type
node: class.
:param node: The node instance that you want to delete.</p>
<p>:type
name: str.
:param name: The name of the attribute. The name has to be
unique as it is used as a key to store the node
object.</p>
<p>:type
index: int.
:param index: The index of the attribute in the node.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p>
<p>:type
plug: bool.
:param plug: Whether or not this attribute can emit connections.</p>
<p>:type
socket: bool.
:param socket: Whether or not this attribute can receive
connections.</p>
<p>:type
dataType: type.
:param dataType: Type of the data represented by this attribute
in order to highlight attributes of the same
type while performing a connection.</p>
<p>:type
plugMaxConnections: int.
:param plugMaxConnections: The maximum connections that the plug can have (-1 for infinite).</p>
<p>:type
socketMaxConnections: int.
:param socketMaxConnections: The maximum connections that the socket can have (-1 for infinite).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createAttribute(self, node, name=&#39;default&#39;, index=-1, preset=&#39;attr_default&#39;, plug=True, socket=True, dataType=None, plugMaxConnections=-1, socketMaxConnections=1):
    &#34;&#34;&#34;
    Create a new attribute with a given name.

    :type  node: class.
    :param node: The node instance that you want to delete.

    :type  name: str.
    :param name: The name of the attribute. The name has to be
                 unique as it is used as a key to store the node
                 object.

    :type  index: int.
    :param index: The index of the attribute in the node.

    :type  preset: str.
    :param preset: The name of graphical preset in the config file.

    :type  plug: bool.
    :param plug: Whether or not this attribute can emit connections.

    :type  socket: bool.
    :param socket: Whether or not this attribute can receive
                   connections.

    :type  dataType: type.
    :param dataType: Type of the data represented by this attribute
                     in order to highlight attributes of the same
                     type while performing a connection.

    :type  plugMaxConnections: int.
    :param plugMaxConnections: The maximum connections that the plug can have (-1 for infinite).

    :type  socketMaxConnections: int.
    :param socketMaxConnections: The maximum connections that the socket can have (-1 for infinite).

    &#34;&#34;&#34;
    if not node in self.scene().nodes.values():
        print(&#39;Node object does not exist !&#39;)
        print(&#39;Attribute creation aborted !&#39;)
        return

    if name in node.attrs:
        print(&#39;An attribute with the same name already exists : {0}&#39;.format(name))
        print(&#39;Attribute creation aborted !&#39;)
        return

    node._createAttribute(name=name, index=index, preset=preset, plug=plug, socket=socket, dataType=dataType, plugMaxConnections=plugMaxConnections, socketMaxConnections=socketMaxConnections)

    # Emit pyqtSignal.
    self.pyqtSignal_AttrCreated.emit(node.name, index)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createConnection"><code class="name flex">
<span>def <span class="ident">createConnection</span></span>(<span>self, sourceNode, sourceAttr, targetNode, targetAttr)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a manual connection.</p>
<p>:type
sourceNode: str.
:param sourceNode: Node that emits the connection.</p>
<p>:type
sourceAttr: str.
:param sourceAttr: Attribute that emits the connection.</p>
<p>:type
targetNode: str.
:param targetNode: Node that receives the connection.</p>
<p>:type
targetAttr: str.
:param targetAttr: Attribute that receives the connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createConnection(self, sourceNode, sourceAttr, targetNode, targetAttr):
    &#34;&#34;&#34;
    Create a manual connection.

    :type  sourceNode: str.
    :param sourceNode: Node that emits the connection.

    :type  sourceAttr: str.
    :param sourceAttr: Attribute that emits the connection.

    :type  targetNode: str.
    :param targetNode: Node that receives the connection.

    :type  targetAttr: str.
    :param targetAttr: Attribute that receives the connection.

    &#34;&#34;&#34;
    plug = self.scene().nodes[sourceNode].plugs[sourceAttr]
    socket = self.scene().nodes[targetNode].sockets[targetAttr]

    connection = ConnectionItem(plug.center(), socket.center(), plug, socket)

    connection.plugNode = plug.parentItem().name
    connection.plugAttr = plug.attribute
    connection.socketNode = socket.parentItem().name
    connection.socketAttr = socket.attribute

    plug.connect(socket, connection)
    socket.connect(plug, connection)

    connection.updatePath()

    self.scene().addItem(connection)

    return connection</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createNode"><code class="name flex">
<span>def <span class="ident">createNode</span></span>(<span>self, name='default', preset='node_default', position=None, alternate=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new node with a given name, position and color.</p>
<p>:type
name: str.
:param name: The name of the node. The name has to be unique
as it is used as a key to store the node object.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p>
<p>:type
position: QtCore.QPoint.
:param position: The position of the node once created. If None,
it will be created at the center of the scene.</p>
<p>:type
alternate: bool.
:param alternate: The attribute color alternate state, if True,
every 2 attribute the color will be slightly
darker.</p>
<p>:return : The created node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNode(self, name=&#39;default&#39;, preset=&#39;node_default&#39;, position=None, alternate=True):
    &#34;&#34;&#34;
    Create a new node with a given name, position and color.

    :type  name: str.
    :param name: The name of the node. The name has to be unique
                 as it is used as a key to store the node object.

    :type  preset: str.
    :param preset: The name of graphical preset in the config file.

    :type  position: QtCore.QPoint.
    :param position: The position of the node once created. If None,
                     it will be created at the center of the scene.

    :type  alternate: bool.
    :param alternate: The attribute color alternate state, if True,
                      every 2 attribute the color will be slightly
                      darker.

    :return : The created node

    &#34;&#34;&#34;
    # Check for name clashes
    if name in self.scene().nodes.keys():
        print(&#39;A node with the same name already exists : {0}&#39;.format(name))
        print(&#39;Node creation aborted !&#39;)
        return
    else:
        nodeItem = NodeItem(name=name, alternate=alternate, preset=preset,
                            config=self.config)

        # Store node in scene.
        self.scene().nodes[name] = nodeItem

        if not position:
            # Get the center of the view.
            position = self.mapToScene(self.viewport().rect().center())

        # Set node position.
        self.scene().addItem(nodeItem)
        nodeItem.setPos(position - nodeItem.nodeCenter)

        # Emit pyqtSignal.
        self.pyqtSignal_NodeCreated.emit(name)

        return nodeItem</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteAttribute"><code class="name flex">
<span>def <span class="ident">deleteAttribute</span></span>(<span>self, node, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the specified attribute.</p>
<p>:type
node: class.
:param node: The node instance that you want to delete.</p>
<p>:type
index: int.
:param index: The index of the attribute in the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteAttribute(self, node, index):
    &#34;&#34;&#34;
    Delete the specified attribute.

    :type  node: class.
    :param node: The node instance that you want to delete.

    :type  index: int.
    :param index: The index of the attribute in the node.

    &#34;&#34;&#34;
    if not node in self.scene().nodes.values():
        print(&#39;Node object does not exist !&#39;)
        print(&#39;Attribute deletion aborted !&#39;)
        return

    node._deleteAttribute(index)

    # Emit pyqtSignal.
    self.pyqtSignal_AttrDeleted.emit(node.name, index)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteNode"><code class="name flex">
<span>def <span class="ident">deleteNode</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the specified node from the view.</p>
<p>:type
node: class.
:param node: The node instance that you want to delete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteNode(self, node):
    &#34;&#34;&#34;
    Delete the specified node from the view.

    :type  node: class.
    :param node: The node instance that you want to delete.

    &#34;&#34;&#34;
    if not node in self.scene().nodes.values():
        print(&#39;Node object does not exist !&#39;)
        print(&#39;Node deletion aborted !&#39;)
        return

    if node in self.scene().nodes.values():
        nodeName = node.name
        node._remove()

        # Emit pyqtSignal.
        self.pyqtSignal_NodeDeleted.emit([nodeName])</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.editAttribute"><code class="name flex">
<span>def <span class="ident">editAttribute</span></span>(<span>self, node, index, newName=None, newIndex=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit the specified attribute.</p>
<p>:type
node: class.
:param node: The node instance that you want to delete.</p>
<p>:type
index: int.
:param index: The index of the attribute in the node.</p>
<p>:type
newName: str.
:param newName: The new name for the given attribute.</p>
<p>:type
newIndex: int.
:param newIndex: The index for the given attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editAttribute(self, node, index, newName=None, newIndex=None):
    &#34;&#34;&#34;
    Edit the specified attribute.

    :type  node: class.
    :param node: The node instance that you want to delete.

    :type  index: int.
    :param index: The index of the attribute in the node.

    :type  newName: str.
    :param newName: The new name for the given attribute.

    :type  newIndex: int.
    :param newIndex: The index for the given attribute.

    &#34;&#34;&#34;
    if not node in self.scene().nodes.values():
        print(&#39;Node object does not exist !&#39;)
        print(&#39;Attribute creation aborted !&#39;)
        return

    if newName != None:
        if newName in node.attrs:
            print(&#39;An attribute with the same name already exists : {0}&#39;.format(newName))
            print(&#39;Attribute edition aborted !&#39;)
            return
        else:
            oldName = node.attrs[index]

        # Rename in the pyqtSlot item(s).
        if node.attrsData[oldName][&#39;plug&#39;]:
            node.plugs[oldName].attribute = newName
            node.plugs[newName] = node.plugs[oldName]
            node.plugs.pop(oldName)
            for connection in node.plugs[newName].connections:
                connection.plugAttr = newName

        if node.attrsData[oldName][&#39;socket&#39;]:
            node.sockets[oldName].attribute = newName
            node.sockets[newName] = node.sockets[oldName]
            node.sockets.pop(oldName)
            for connection in node.sockets[newName].connections:
                connection.socketAttr = newName

        # Replace attribute data.
        node.attrsData[oldName][&#39;name&#39;] = newName
        node.attrsData[newName] = node.attrsData[oldName]
        node.attrsData.pop(oldName)
        node.attrs[index] = newName

    if isinstance(newIndex, int):
        attrName = node.attrs[index]

        utils._swapListIndices(node.attrs, index, newIndex)

        # Refresh connections.
        for plug in node.plugs.values():
            plug.update()
            if plug.connections:
                for connection in plug.connections:
                    if isinstance(connection.source, PlugItem):
                        connection.source = plug
                        connection.source_point = plug.center()
                    else:
                        connection.target = plug
                        connection.target_point = plug.center()
                    if newName:
                        connection.plugAttr = newName
                    connection.updatePath()

        for socket in node.sockets.values():
            socket.update()
            if socket.connections:
                for connection in socket.connections:
                    if isinstance(connection.source, SocketItem):
                        connection.source = socket
                        connection.source_point = socket.center()
                    else:
                        connection.target = socket
                        connection.target_point = socket.center()
                    if newName:
                        connection.socketAttr = newName
                    connection.updatePath()

        self.scene().update()

    node.update()

    # Emit pyqtSignal.
    if newIndex:
        self.pyqtSignal_AttrEdited.emit(node.name, index, newIndex)
    else:
        self.pyqtSignal_AttrEdited.emit(node.name, index, index)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.editNode"><code class="name flex">
<span>def <span class="ident">editNode</span></span>(<span>self, node, newName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename an existing node.</p>
<p>:type
node: class.
:param node: The node instance that you want to delete.</p>
<p>:type
newName: str.
:param newName: The new name for the given node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editNode(self, node, newName=None):
    &#34;&#34;&#34;
    Rename an existing node.

    :type  node: class.
    :param node: The node instance that you want to delete.

    :type  newName: str.
    :param newName: The new name for the given node.

    &#34;&#34;&#34;
    if not node in self.scene().nodes.values():
        print(&#39;Node object does not exist !&#39;)
        print(&#39;Node edition aborted !&#39;)
        return

    oldName = node.name

    if newName != None:
        # Check for name clashes
        if newName in self.scene().nodes.keys():
            print(&#39;A node with the same name already exists : {0}&#39;.format(newName))
            print(&#39;Node edition aborted !&#39;)
            return
        else:
            node.name = newName

    # Replace node data.
    self.scene().nodes[newName] = self.scene().nodes[oldName]
    self.scene().nodes.pop(oldName)

    # Store new node name in the connections
    if node.sockets:
        for socket in node.sockets.values():
            for connection in socket.connections:
                connection.socketNode = newName

    if node.plugs:
        for plug in node.plugs.values():
            for connection in plug.connections:
                connection.plugNode = newName

    node.update()

    # Emit pyqtSignal.
    self.pyqtSignal_NodeEdited.emit(oldName, newName)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.evaluateGraph"><code class="name flex">
<span>def <span class="ident">evaluateGraph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a list of connection tuples.
[("sourceNode.attribute", "TargetNode.attribute"), &hellip;]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluateGraph(self):
    &#34;&#34;&#34;
    Create a list of connection tuples.
    [(&#34;sourceNode.attribute&#34;, &#34;TargetNode.attribute&#34;), ...]

    &#34;&#34;&#34;
    scene = self.scene()

    data = list()

    for item in scene.items():
        if isinstance(item, ConnectionItem):
            connection = item

            data.append(connection._outputConnectionData())

    # Emit pyqtSignal
    self.pyqtSignal_GraphEvaluated.emit()

    return data</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup the view's behavior.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;
    Setup the view&#39;s behavior.

    &#34;&#34;&#34;
    # Setup view.
    config = self.config
    self.setRenderHint(QtGui.QPainter.Antialiasing, config[&#39;antialiasing&#39;])
    self.setRenderHint(QtGui.QPainter.TextAntialiasing, config[&#39;antialiasing&#39;])
    self.setRenderHint(QtGui.QPainter.HighQualityAntialiasing, config[&#39;antialiasing_boost&#39;])
    self.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, config[&#39;smooth_pixmap&#39;])
    self.setRenderHint(QtGui.QPainter.NonCosmeticDefaultPen, True)
    self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
    self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
    self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.rubberband = QtWidgets.QRubberBand(QtWidgets.QRubberBand.Rectangle, self)

    # Setup scene.
    scene = NodeScene(self)
    sceneWidth = config[&#39;scene_width&#39;]
    sceneHeight = config[&#39;scene_height&#39;]
    scene.setSceneRect(0, 0, sceneWidth, sceneHeight)
    self.setScene(scene)
    # Connect scene node moved pyqtSignal
    scene.pyqtSignal_NodeMoved.connect(self.pyqtSignal_NodeMoved)

    # Tablet zoom.
    self.previousMouseOffset = 0
    self.zoomDirection = 0
    self.zoomIncr = 0

    # Connect pyqtSignals.
    self.scene().selectionChanged.connect(self._returnSelection)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyPressEvent"><code class="name flex">
<span>def <span class="ident">keyPressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Save pressed key and apply shortcuts.</p>
<p>Shortcuts are:
DEL - Delete the selected nodes
F - Focus view on the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyPressEvent(self, event):
    &#34;&#34;&#34;
    Save pressed key and apply shortcuts.

    Shortcuts are:
    DEL - Delete the selected nodes
    F - Focus view on the selection

    &#34;&#34;&#34;
    if event.key() not in self.pressedKeys:
        self.pressedKeys.append(event.key())

    if event.key() in (QtCore.Qt.Key_Delete, QtCore.Qt.Key_Backspace):
        self._deleteSelectedNodes()

    if event.key() == QtCore.Qt.Key_F:
        self._focus()

    if event.key() == QtCore.Qt.Key_S:
        self._nodeSnap = True

    # Emit pyqtSignal.
    self.pyqtSignal_KeyPressed.emit(event.key())</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyReleaseEvent"><code class="name flex">
<span>def <span class="ident">keyReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the key from the pressed key list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyReleaseEvent(self, event):
    &#34;&#34;&#34;
    Clear the key from the pressed key list.

    &#34;&#34;&#34;
    if event.key() == QtCore.Qt.Key_S:
        self._nodeSnap = False

    if event.key() in self.pressedKeys:
        self.pressedKeys.remove(event.key())</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadConfig"><code class="name flex">
<span>def <span class="ident">loadConfig</span></span>(<span>self, filePath)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a specific configuration for this instance of Nodz.</p>
<p>:type
filePath: str.
:param filePath: The path to the config file that you want to
use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadConfig(self, filePath):
    &#34;&#34;&#34;
    Set a specific configuration for this instance of Nodz.

    :type  filePath: str.
    :param filePath: The path to the config file that you want to
                     use.

    &#34;&#34;&#34;
    self.config = utils._loadConfig(filePath)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadGraph"><code class="name flex">
<span>def <span class="ident">loadGraph</span></span>(<span>self, filePath='path')</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the stored info from the .json file at the given location
and recreate the graph as saved.</p>
<p>:type
filePath: str.
:param filePath: The path where you want to load your graph from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadGraph(self, filePath=&#39;path&#39;):
    &#34;&#34;&#34;
    Get all the stored info from the .json file at the given location
    and recreate the graph as saved.

    :type  filePath: str.
    :param filePath: The path where you want to load your graph from.

    &#34;&#34;&#34;
    # Load data.
    if os.path.exists(filePath):
        data = utils._loadData(filePath=filePath)
    else:
        print(&#39;Invalid path : {0}&#39;.format(filePath))
        print(&#39;Load aborted !&#39;)
        return False

    # Apply nodes data.
    nodesData = data[&#39;NODES&#39;]
    nodesName = nodesData.keys()

    for name in nodesName:
        preset = nodesData[name][&#39;preset&#39;]
        position = nodesData[name][&#39;position&#39;]
        position = QtCore.QPointF(position[0], position[1])
        alternate = nodesData[name][&#39;alternate&#39;]

        node = self.createNode(name=name,
                               preset=preset,
                               position=position,
                               alternate=alternate)

        # Apply attributes data.
        attrsData = nodesData[name][&#39;attributes&#39;]

        for attrData in attrsData:
            index = attrsData.index(attrData)
            name = attrData[&#39;name&#39;]
            plug = attrData[&#39;plug&#39;]
            socket = attrData[&#39;socket&#39;]
            preset = attrData[&#39;preset&#39;]
            dataType = attrData[&#39;dataType&#39;]
            plugMaxConnections = attrData[&#39;plugMaxConnections&#39;]
            socketMaxConnections = attrData[&#39;socketMaxConnections&#39;]

            # un-serialize data type if needed
            if (isinstance(dataType, str) and dataType.find(&#39;&lt;&#39;) == 0):
                dataType = eval(str(dataType.split(&#39;\&#39;&#39;)[1]))

            self.createAttribute(node=node,
                                 name=name,
                                 index=index,
                                 preset=preset,
                                 plug=plug,
                                 socket=socket,
                                 dataType=dataType,
                                 plugMaxConnections=plugMaxConnections,
                                 socketMaxConnections=socketMaxConnections
                                 )

    # Apply connections data.
    connectionsData = data[&#39;CONNECTIONS&#39;]

    for connection in connectionsData:
        source = connection[0]
        sourceNode = source.split(&#39;.&#39;)[0]
        sourceAttr = source.split(&#39;.&#39;)[1]

        target = connection[1]
        targetNode = target.split(&#39;.&#39;)[0]
        targetAttr = target.split(&#39;.&#39;)[1]

        self.createConnection(sourceNode, sourceAttr,
                              targetNode, targetAttr)

    self.scene().update()

    # Emit pyqtSignal.
    self.pyqtSignal_GraphLoaded.emit()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Update tablet zoom, canvas dragging and selection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    &#34;&#34;&#34;
    Update tablet zoom, canvas dragging and selection.

    &#34;&#34;&#34;
    # Zoom.
    if self.currentState == &#39;ZOOM_VIEW&#39;:
        offset = self.zoomInitialPos.x() - event.pos().x()

        if offset &gt; self.previousMouseOffset:
            self.previousMouseOffset = offset
            self.zoomDirection = -1
            self.zoomIncr -= 1

        elif offset == self.previousMouseOffset:
            self.previousMouseOffset = offset
            if self.zoomDirection == -1:
                self.zoomDirection = -1
            else:
                self.zoomDirection = 1

        else:
            self.previousMouseOffset = offset
            self.zoomDirection = 1
            self.zoomIncr += 1

        if self.zoomDirection == 1:
            zoomFactor = 1.03
        else:
            zoomFactor = 1 / 1.03

        # Perform zoom and re-center on initial click position.
        pBefore = self.mapToScene(self.initMousePos)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorViewCenter)
        self.scale(zoomFactor, zoomFactor)
        pAfter = self.mapToScene(self.initMousePos)
        diff = pAfter - pBefore

        self.setTransformationAnchor(QtWidgets.QGraphicsView.NoAnchor)
        self.translate(diff.x(), diff.y())
        pass

    # Drag canvas.
    elif self.currentState == &#39;DRAG_VIEW&#39;:
        offset = self.prevPos - event.pos()
        self.prevPos = event.pos()
        self.verticalScrollBar().setValue(self.verticalScrollBar().value() + offset.y())
        self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() + offset.x())

    # RuberBand selection.
    elif (self.currentState == &#39;SELECTION&#39; or
          self.currentState == &#39;ADD_SELECTION&#39; or
          self.currentState == &#39;SUBTRACT_SELECTION&#39; or
          self.currentState == &#39;TOGGLE_SELECTION&#39;):
        self.rubberband.setGeometry(QtCore.QRect(self.origin, event.pos()).normalized())

    super(Nodz, self).mouseMoveEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize tablet zoom, drag canvas and the selection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    &#34;&#34;&#34;
    Initialize tablet zoom, drag canvas and the selection.

    &#34;&#34;&#34;
    # Tablet zoom
    if (event.button() == QtCore.Qt.RightButton and
        event.modifiers() == QtCore.Qt.AltModifier):
        self.currentState = &#39;ZOOM_VIEW&#39;
        self.initMousePos = event.pos()
        self.zoomInitialPos = event.pos()
        self.initMouse = QtGui.QCursor.pos()
        self.setInteractive(False)


    # Drag view
    elif (event.button() == QtCore.Qt.MiddleButton and
          event.modifiers() == QtCore.Qt.AltModifier):
        self.currentState = &#39;DRAG_VIEW&#39;
        self.prevPos = event.pos()
        self.setCursor(QtCore.Qt.ClosedHandCursor)
        self.setInteractive(False)


    # Rubber band selection
    elif (event.button() == QtCore.Qt.LeftButton and
          event.modifiers() == QtCore.Qt.NoModifier and
          self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is None):
        self.currentState = &#39;SELECTION&#39;
        self._initRubberband(event.pos())
        self.setInteractive(False)


    # Drag Item
    elif (event.button() == QtCore.Qt.LeftButton and
          event.modifiers() == QtCore.Qt.NoModifier and
          self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is not None):
        self.currentState = &#39;DRAG_ITEM&#39;
        self.setInteractive(True)


    # Add selection
    elif (event.button() == QtCore.Qt.LeftButton and
          QtCore.Qt.Key_Shift in self.pressedKeys and
          QtCore.Qt.Key_Control in self.pressedKeys):
        self.currentState = &#39;ADD_SELECTION&#39;
        self._initRubberband(event.pos())
        self.setInteractive(False)


    # Subtract selection
    elif (event.button() == QtCore.Qt.LeftButton and
          event.modifiers() == QtCore.Qt.ControlModifier):
        self.currentState = &#39;SUBTRACT_SELECTION&#39;
        self._initRubberband(event.pos())
        self.setInteractive(False)


    # Toggle selection
    elif (event.button() == QtCore.Qt.LeftButton and
          event.modifiers() == QtCore.Qt.ShiftModifier):
        self.currentState = &#39;TOGGLE_SELECTION&#39;
        self._initRubberband(event.pos())
        self.setInteractive(False)


    else:
        self.currentState = &#39;DEFAULT&#39;

    super(Nodz, self).mousePressEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply tablet zoom, dragging and selection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, event):
    &#34;&#34;&#34;
    Apply tablet zoom, dragging and selection.

    &#34;&#34;&#34;
    # Zoom the View.
    if self.currentState == &#39;.ZOOM_VIEW&#39;:
        self.offset = 0
        self.zoomDirection = 0
        self.zoomIncr = 0
        self.setInteractive(True)


    # Drag View.
    elif self.currentState == &#39;DRAG_VIEW&#39;:
        self.setCursor(QtCore.Qt.ArrowCursor)
        self.setInteractive(True)


    # Selection.
    elif self.currentState == &#39;SELECTION&#39;:
        self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                 event.pos()).normalized())
        painterPath = self._releaseRubberband()
        self.setInteractive(True)
        self.scene().setSelectionArea(painterPath)


    # Add Selection.
    elif self.currentState == &#39;ADD_SELECTION&#39;:
        self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                 event.pos()).normalized())
        painterPath = self._releaseRubberband()
        self.setInteractive(True)
        for item in self.scene().items(painterPath):
            item.setSelected(True)


    # Subtract Selection.
    elif self.currentState == &#39;SUBTRACT_SELECTION&#39;:
        self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                 event.pos()).normalized())
        painterPath = self._releaseRubberband()
        self.setInteractive(True)
        for item in self.scene().items(painterPath):
            item.setSelected(False)


    # Toggle Selection
    elif self.currentState == &#39;TOGGLE_SELECTION&#39;:
        self.rubberband.setGeometry(QtCore.QRect(self.origin,
                                                 event.pos()).normalized())
        painterPath = self._releaseRubberband()
        self.setInteractive(True)
        for item in self.scene().items(painterPath):
            if item.isSelected():
                item.setSelected(False)
            else:
                item.setSelected(True)

    self.currentState = &#39;DEFAULT&#39;

    super(Nodz, self).mouseReleaseEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrCreated"><code class="name flex">
<span>def <span class="ident">pyqtSignal_AttrCreated</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrDeleted"><code class="name flex">
<span>def <span class="ident">pyqtSignal_AttrDeleted</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrEdited"><code class="name flex">
<span>def <span class="ident">pyqtSignal_AttrEdited</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_Dropped"><code class="name flex">
<span>def <span class="ident">pyqtSignal_Dropped</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphCleared"><code class="name flex">
<span>def <span class="ident">pyqtSignal_GraphCleared</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphEvaluated"><code class="name flex">
<span>def <span class="ident">pyqtSignal_GraphEvaluated</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphLoaded"><code class="name flex">
<span>def <span class="ident">pyqtSignal_GraphLoaded</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphSaved"><code class="name flex">
<span>def <span class="ident">pyqtSignal_GraphSaved</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_KeyPressed"><code class="name flex">
<span>def <span class="ident">pyqtSignal_KeyPressed</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeCreated"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeCreated</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDeleted"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeDeleted</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDoubleClicked"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeDoubleClicked</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeEdited"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeEdited</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeMoved"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeMoved</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeSelected"><code class="name flex">
<span>def <span class="ident">pyqtSignal_NodeSelected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugConnected"><code class="name flex">
<span>def <span class="ident">pyqtSignal_PlugConnected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugDisconnected"><code class="name flex">
<span>def <span class="ident">pyqtSignal_PlugDisconnected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketConnected"><code class="name flex">
<span>def <span class="ident">pyqtSignal_SocketConnected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketDisconnected"><code class="name flex">
<span>def <span class="ident">pyqtSignal_SocketDisconnected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.saveGraph"><code class="name flex">
<span>def <span class="ident">saveGraph</span></span>(<span>self, filePath='path')</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the current graph infos and store them in a .json file
at the given location.</p>
<p>:type
filePath: str.
:param filePath: The path where you want to save your graph at.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveGraph(self, filePath=&#39;path&#39;):
    &#34;&#34;&#34;
    Get all the current graph infos and store them in a .json file
    at the given location.

    :type  filePath: str.
    :param filePath: The path where you want to save your graph at.

    &#34;&#34;&#34;
    data = dict()

    # Store nodes data.
    data[&#39;NODES&#39;] = dict()

    nodes = self.scene().nodes.keys()
    for node in nodes:
        nodeInst = self.scene().nodes[node]
        preset = nodeInst.nodePreset
        nodeAlternate = nodeInst.alternate

        data[&#39;NODES&#39;][node] = {&#39;preset&#39;: preset,
                               &#39;position&#39;: [nodeInst.pos().x(), nodeInst.pos().y()],
                               &#39;alternate&#39;: nodeAlternate,
                               &#39;attributes&#39;: []}

        attrs = nodeInst.attrs
        for attr in attrs:
            attrData = nodeInst.attrsData[attr]

            # serialize dataType if needed.
            if isinstance(attrData[&#39;dataType&#39;], type):
                attrData[&#39;dataType&#39;] = str(attrData[&#39;dataType&#39;])

            data[&#39;NODES&#39;][node][&#39;attributes&#39;].append(attrData)


    # Store connections data.
    data[&#39;CONNECTIONS&#39;] = self.evaluateGraph()


    # Save data.
    try:
        utils._saveData(filePath=filePath, data=data)
    except:
        print(&#39;Invalid path : {0}&#39;.format(filePath))
        print(&#39;Save aborted !&#39;)
        return False

    # Emit pyqtSignal.
    self.pyqtSignal_GraphSaved.emit()</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.Nodz.wheelEvent"><code class="name flex">
<span>def <span class="ident">wheelEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Zoom in the view with the mouse wheel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wheelEvent(self, event):
    &#34;&#34;&#34;
    Zoom in the view with the mouse wheel.

    &#34;&#34;&#34;
    self.currentState = &#39;ZOOM_VIEW&#39;
    self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

    inFactor = 1.15
    outFactor = 1 / inFactor

    if event.angleDelta().y() &gt; 0:
        zoomFactor = inFactor
    else:
        zoomFactor = outFactor

    self.scale(zoomFactor, zoomFactor)
    self.currentState = &#39;DEFAULT&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.PlugItem"><code class="flex name class">
<span>class <span class="ident">PlugItem</span></span>
<span>(</span><span>parent, attribute, index, preset, dataType, maxConnections)</span>
</code></dt>
<dd>
<div class="desc"><p>A graphics item representing an attribute out hook.</p>
<p>Initialize the class.</p>
<p>:param parent: The parent item of the pyqtSlot.
:type
parent: QtWidgets.QGraphicsItem instance.</p>
<p>:param attribute: The attribute associated to the pyqtSlot.
:type
attribute: String.</p>
<p>:param index: int.
:type
index: The index of the attribute in the node.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p>
<p>:param dataType: The data type associated to the attribute.
:type
dataType: Type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlugItem(pyqtSlotItem):

    &#34;&#34;&#34;
    A graphics item representing an attribute out hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, index, preset, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the class.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(PlugItem, self).__init__(parent, attribute, preset, index, dataType, maxConnections)

        # Storage.
        self.attributte = attribute
        self.preset = preset
        self.pyqtSlotType = &#39;plug&#39;

        # Methods.
        self._createStyle(parent)

    def _createStyle(self, parent):
        &#34;&#34;&#34;
        Read the attribute style from the configuration file.

        &#34;&#34;&#34;
        config = parent.scene().views()[0].config
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)
        self.brush.setColor(utils._convertDataToColor(config[self.preset][&#39;plug&#39;]))

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        width = height = self.parentItem().attrHeight / 2.0

        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        x = self.parentItem().baseWidth - (width / 2.0)
        y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
             self.parentItem().attrHeight / 4 +
             self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight)

        rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
        return rect

    def connect(self, socket_item, connection):
        &#34;&#34;&#34;
        Connect to the given socket_item.

        &#34;&#34;&#34;
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            # Already connected.
            self.connections[self.maxConnections-1]._remove()

        # Populate connection.
        connection.socketItem = socket_item
        connection.plugNode = self.parentItem().name
        connection.plugAttr = self.attribute

        # Add socket to connected pyqtSlots.
        if socket_item in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(socket_item)
        self.connected_pyqtSlots.append(socket_item)

        # Add connection.
        if connection not in self.connections:
            self.connections.append(connection)

        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_PlugConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    def disconnect(self, connection):
        &#34;&#34;&#34;
        Disconnect the given connection from this plug item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_PlugDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

        # Remove connected socket from plug
        if connection.socketItem in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(connection.socketItem)
        # Remove connection
        self.connections.remove(connection)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem">pyqtSlotItem</a></li>
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding rect based on the width and height variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self):
    &#34;&#34;&#34;
    The bounding rect based on the width and height variables.

    &#34;&#34;&#34;
    width = height = self.parentItem().attrHeight / 2.0

    nodzInst = self.scene().views()[0]
    config = nodzInst.config

    x = self.parentItem().baseWidth - (width / 2.0)
    y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
         self.parentItem().attrHeight / 4 +
         self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight)

    rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
    return rect</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, socket_item, connection)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the given socket_item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, socket_item, connection):
    &#34;&#34;&#34;
    Connect to the given socket_item.

    &#34;&#34;&#34;
    if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
        # Already connected.
        self.connections[self.maxConnections-1]._remove()

    # Populate connection.
    connection.socketItem = socket_item
    connection.plugNode = self.parentItem().name
    connection.plugAttr = self.attribute

    # Add socket to connected pyqtSlots.
    if socket_item in self.connected_pyqtSlots:
        self.connected_pyqtSlots.remove(socket_item)
    self.connected_pyqtSlots.append(socket_item)

    # Add connection.
    if connection not in self.connections:
        self.connections.append(connection)

    # Emit pyqtSignal.
    nodzInst = self.scene().views()[0]
    nodzInst.pyqtSignal_PlugConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, connection)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect the given connection from this plug item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, connection):
    &#34;&#34;&#34;
    Disconnect the given connection from this plug item.

    &#34;&#34;&#34;
    # Emit pyqtSignal.
    nodzInst = self.scene().views()[0]
    nodzInst.pyqtSignal_PlugDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    # Remove connected socket from plug
    if connection.socketItem in self.connected_pyqtSlots:
        self.connected_pyqtSlots.remove(connection.socketItem)
    # Remove connection
    self.connections.remove(connection)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem">pyqtSlotItem</a></b></code>:
<ul class="hlist">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts">accepts</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center">center</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint">paint</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.SocketItem"><code class="flex name class">
<span>class <span class="ident">SocketItem</span></span>
<span>(</span><span>parent, attribute, index, preset, dataType, maxConnections)</span>
</code></dt>
<dd>
<div class="desc"><p>A graphics item representing an attribute in hook.</p>
<p>Initialize the socket.</p>
<p>:param parent: The parent item of the pyqtSlot.
:type
parent: QtWidgets.QGraphicsItem instance.</p>
<p>:param attribute: The attribute associated to the pyqtSlot.
:type
attribute: String.</p>
<p>:param index: int.
:type
index: The index of the attribute in the node.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p>
<p>:param dataType: The data type associated to the attribute.
:type
dataType: Type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocketItem(pyqtSlotItem):

    &#34;&#34;&#34;
    A graphics item representing an attribute in hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, index, preset, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the socket.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(SocketItem, self).__init__(parent, attribute, preset, index, dataType, maxConnections)

        # Storage.
        self.attributte = attribute
        self.preset = preset
        self.pyqtSlotType = &#39;socket&#39;

        # Methods.
        self._createStyle(parent)

    def _createStyle(self, parent):
        &#34;&#34;&#34;
        Read the attribute style from the configuration file.

        &#34;&#34;&#34;
        config = parent.scene().views()[0].config
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)
        self.brush.setColor(utils._convertDataToColor(config[self.preset][&#39;socket&#39;]))

    def boundingRect(self):
        &#34;&#34;&#34;
        The bounding rect based on the width and height variables.

        &#34;&#34;&#34;
        width = height = self.parentItem().attrHeight / 2.0

        nodzInst = self.scene().views()[0]
        config = nodzInst.config

        x = - width / 2.0
        y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
            (self.parentItem().attrHeight/4) +
             self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight )

        rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
        return rect

    def connect(self, plug_item, connection):
        &#34;&#34;&#34;
        Connect to the given plug item.

        &#34;&#34;&#34;
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            # Already connected.
            self.connections[self.maxConnections-1]._remove()

        # Populate connection.
        connection.plugItem = plug_item
        connection.socketNode = self.parentItem().name
        connection.socketAttr = self.attribute

        # Add plug to connected pyqtSlots.
        self.connected_pyqtSlots.append(plug_item)

        # Add connection.
        if connection not in self.connections:
            self.connections.append(connection)

        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_SocketConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    def disconnect(self, connection):
        &#34;&#34;&#34;
        Disconnect the given connection from this socket item.

        &#34;&#34;&#34;
        # Emit pyqtSignal.
        nodzInst = self.scene().views()[0]
        nodzInst.pyqtSignal_SocketDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

        # Remove connected plugs
        if connection.plugItem in self.connected_pyqtSlots:
            self.connected_pyqtSlots.remove(connection.plugItem)
        # Remove connections
        self.connections.remove(connection)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem">pyqtSlotItem</a></li>
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding rect based on the width and height variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self):
    &#34;&#34;&#34;
    The bounding rect based on the width and height variables.

    &#34;&#34;&#34;
    width = height = self.parentItem().attrHeight / 2.0

    nodzInst = self.scene().views()[0]
    config = nodzInst.config

    x = - width / 2.0
    y = (self.parentItem().baseHeight - config[&#39;node_radius&#39;] +
        (self.parentItem().attrHeight/4) +
         self.parentItem().attrs.index(self.attribute) * self.parentItem().attrHeight )

    rect = QtCore.QRectF(QtCore.QRect(x, y, width, height))
    return rect</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, plug_item, connection)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the given plug item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, plug_item, connection):
    &#34;&#34;&#34;
    Connect to the given plug item.

    &#34;&#34;&#34;
    if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
        # Already connected.
        self.connections[self.maxConnections-1]._remove()

    # Populate connection.
    connection.plugItem = plug_item
    connection.socketNode = self.parentItem().name
    connection.socketAttr = self.attribute

    # Add plug to connected pyqtSlots.
    self.connected_pyqtSlots.append(plug_item)

    # Add connection.
    if connection not in self.connections:
        self.connections.append(connection)

    # Emit pyqtSignal.
    nodzInst = self.scene().views()[0]
    nodzInst.pyqtSignal_SocketConnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, connection)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect the given connection from this socket item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, connection):
    &#34;&#34;&#34;
    Disconnect the given connection from this socket item.

    &#34;&#34;&#34;
    # Emit pyqtSignal.
    nodzInst = self.scene().views()[0]
    nodzInst.pyqtSignal_SocketDisconnected.emit(connection.plugNode, connection.plugAttr, connection.socketNode, connection.socketAttr)

    # Remove connected plugs
    if connection.plugItem in self.connected_pyqtSlots:
        self.connected_pyqtSlots.remove(connection.plugItem)
    # Remove connections
    self.connections.remove(connection)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem">pyqtSlotItem</a></b></code>:
<ul class="hlist">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts">accepts</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center">center</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint">paint</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem"><code class="flex name class">
<span>class <span class="ident">pyqtSlotItem</span></span>
<span>(</span><span>parent, attribute, preset, index, dataType, maxConnections)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for graphics item representing attributes hook.</p>
<p>Initialize the class.</p>
<p>:param parent: The parent item of the pyqtSlot.
:type
parent: QtWidgets.QGraphicsItem instance.</p>
<p>:param attribute: The attribute associated to the pyqtSlot.
:type
attribute: String.</p>
<p>:param index: int.
:type
index: The index of the attribute in the node.</p>
<p>:type
preset: str.
:param preset: The name of graphical preset in the config file.</p>
<p>:param dataType: The data type associated to the attribute.
:type
dataType: Type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pyqtSlotItem(QtWidgets.QGraphicsItem):

    &#34;&#34;&#34;
    The base class for graphics item representing attributes hook.

    &#34;&#34;&#34;

    def __init__(self, parent, attribute, preset, index, dataType, maxConnections):
        &#34;&#34;&#34;
        Initialize the class.

        :param parent: The parent item of the pyqtSlot.
        :type  parent: QtWidgets.QGraphicsItem instance.

        :param attribute: The attribute associated to the pyqtSlot.
        :type  attribute: String.

        :param index: int.
        :type  index: The index of the attribute in the node.

        :type  preset: str.
        :param preset: The name of graphical preset in the config file.

        :param dataType: The data type associated to the attribute.
        :type  dataType: Type.

        &#34;&#34;&#34;
        super(pyqtSlotItem, self).__init__(parent)

        # Status.
        self.setAcceptHoverEvents(True)

        # Storage.
        self.pyqtSlotType = None
        self.attribute = attribute
        self.preset = preset
        self.index = index
        self.dataType = dataType

        # Style.
        self.brush = QtGui.QBrush()
        self.brush.setStyle(QtCore.Qt.SolidPattern)

        self.pen = QtGui.QPen()
        self.pen.setStyle(QtCore.Qt.SolidLine)

        # Connections storage.
        self.connected_pyqtSlots = list()
        self.newConnection = None
        self.connections = list()
        self.maxConnections = maxConnections

    def accepts(self, pyqtSlot_item):
        &#34;&#34;&#34;
        Only accepts plug items that belong to other nodes, and only if the max connections count is not reached yet.

        &#34;&#34;&#34;
        # no plug on plug or socket on socket
        hasPlugItem = isinstance(self, PlugItem) or isinstance(pyqtSlot_item, PlugItem)
        hasSocketItem = isinstance(self, SocketItem) or isinstance(pyqtSlot_item, SocketItem)
        if not (hasPlugItem and hasSocketItem):
            return False

        # no self connection
        if self.parentItem() == pyqtSlot_item.parentItem():
            return False

        #no more than maxConnections
        if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
            return False

        #no connection with different types
        if pyqtSlot_item.dataType != self.dataType:
            return False

        #otherwize, all fine.
        return True

    def mousePressEvent(self, event):
        &#34;&#34;&#34;
        Start the connection process.

        &#34;&#34;&#34;
        if event.button() == QtCore.Qt.LeftButton:
            self.newConnection = ConnectionItem(self.center(),
                                                self.mapToScene(event.pos()),
                                                self,
                                                None)

            self.connections.append(self.newConnection)
            self.scene().addItem(self.newConnection)

            nodzInst = self.scene().views()[0]
            nodzInst.drawingConnection = True
            nodzInst.sourcepyqtSlot = self
            nodzInst.currentDataType = self.dataType
        else:
            super(pyqtSlotItem, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        &#34;&#34;&#34;
        Update the new connection&#39;s end point position.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        config = nodzInst.config
        if nodzInst.drawingConnection:
            mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                                  bbSize=config[&#39;mouse_bounding_box&#39;])

            # Get nodes in pointer&#39;s bounding box.
            targets = self.scene().items(mbb)

            if any(isinstance(target, NodeItem) for target in targets):
                if self.parentItem() not in targets:
                    for target in targets:
                        if isinstance(target, NodeItem):
                            nodzInst.currentHoveredNode = target
            else:
                nodzInst.currentHoveredNode = None

            # Set connection&#39;s end point.
            self.newConnection.target_point = self.mapToScene(event.pos())
            self.newConnection.updatePath()
        else:
            super(pyqtSlotItem, self).mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        &#34;&#34;&#34;
        Apply the connection if target_pyqtSlot is valid.

        &#34;&#34;&#34;
        nodzInst = self.scene().views()[0]
        if event.button() == QtCore.Qt.LeftButton:
            nodzInst.drawingConnection = False
            nodzInst.currentDataType = None

            target = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

            if not isinstance(target, pyqtSlotItem):
                self.newConnection._remove()
                super(pyqtSlotItem, self).mouseReleaseEvent(event)
                return

            if target.accepts(self):
                self.newConnection.target = target
                self.newConnection.source = self
                self.newConnection.target_point = target.center()
                self.newConnection.source_point = self.center()

                # Perform the ConnectionItem.
                self.connect(target, self.newConnection)
                target.connect(self, self.newConnection)

                self.newConnection.updatePath()
            else:
                self.newConnection._remove()
        else:
            super(pyqtSlotItem, self).mouseReleaseEvent(event)

        nodzInst.currentHoveredNode = None

    def shape(self):
        &#34;&#34;&#34;
        The shape of the pyqtSlot is a circle.

        &#34;&#34;&#34;
        path = QtGui.QPainterPath()
        path.addRect(self.boundingRect())
        return path

    def paint(self, painter, option, widget):
        &#34;&#34;&#34;
        Paint the pyqtSlot.

        &#34;&#34;&#34;
        painter.setBrush(self.brush)
        painter.setPen(self.pen)

        nodzInst = self.scene().views()[0]
        config = nodzInst.config
        if nodzInst.drawingConnection:
            if self.parentItem() == nodzInst.currentHoveredNode:
                painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
                if (self.pyqtSlotType == nodzInst.sourcepyqtSlot.pyqtSlotType or (self.pyqtSlotType != nodzInst.sourcepyqtSlot.pyqtSlotType and self.dataType != nodzInst.sourcepyqtSlot.dataType)):
                    painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
                else:
                    _penValid = QtGui.QPen()
                    _penValid.setStyle(QtCore.Qt.SolidLine)
                    _penValid.setWidth(2)
                    _penValid.setColor(QtGui.QColor(255, 255, 255, 255))
                    painter.setPen(_penValid)
                    painter.setBrush(self.brush)

        painter.drawEllipse(self.boundingRect())

    def center(self):
        &#34;&#34;&#34;
        Return The center of the pyqtSlot.

        &#34;&#34;&#34;
        rect = self.boundingRect()
        center = QtCore.QPointF(rect.x() + rect.width() * 0.5,
                                rect.y() + rect.height() * 0.5)

        return self.mapToScene(center)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="WizualizacjaAlgorytmow.NodZ.Main.PlugItem" href="#WizualizacjaAlgorytmow.NodZ.Main.PlugItem">PlugItem</a></li>
<li><a title="WizualizacjaAlgorytmow.NodZ.Main.SocketItem" href="#WizualizacjaAlgorytmow.NodZ.Main.SocketItem">SocketItem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts"><code class="name flex">
<span>def <span class="ident">accepts</span></span>(<span>self, pyqtSlot_item)</span>
</code></dt>
<dd>
<div class="desc"><p>Only accepts plug items that belong to other nodes, and only if the max connections count is not reached yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accepts(self, pyqtSlot_item):
    &#34;&#34;&#34;
    Only accepts plug items that belong to other nodes, and only if the max connections count is not reached yet.

    &#34;&#34;&#34;
    # no plug on plug or socket on socket
    hasPlugItem = isinstance(self, PlugItem) or isinstance(pyqtSlot_item, PlugItem)
    hasSocketItem = isinstance(self, SocketItem) or isinstance(pyqtSlot_item, SocketItem)
    if not (hasPlugItem and hasSocketItem):
        return False

    # no self connection
    if self.parentItem() == pyqtSlot_item.parentItem():
        return False

    #no more than maxConnections
    if self.maxConnections&gt;0 and len(self.connected_pyqtSlots) &gt;= self.maxConnections:
        return False

    #no connection with different types
    if pyqtSlot_item.dataType != self.dataType:
        return False

    #otherwize, all fine.
    return True</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return The center of the pyqtSlot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;
    Return The center of the pyqtSlot.

    &#34;&#34;&#34;
    rect = self.boundingRect()
    center = QtCore.QPointF(rect.x() + rect.width() * 0.5,
                            rect.y() + rect.height() * 0.5)

    return self.mapToScene(center)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the new connection's end point position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    &#34;&#34;&#34;
    Update the new connection&#39;s end point position.

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]
    config = nodzInst.config
    if nodzInst.drawingConnection:
        mbb = utils._createPointerBoundingBox(pointerPos=event.scenePos().toPoint(),
                                              bbSize=config[&#39;mouse_bounding_box&#39;])

        # Get nodes in pointer&#39;s bounding box.
        targets = self.scene().items(mbb)

        if any(isinstance(target, NodeItem) for target in targets):
            if self.parentItem() not in targets:
                for target in targets:
                    if isinstance(target, NodeItem):
                        nodzInst.currentHoveredNode = target
        else:
            nodzInst.currentHoveredNode = None

        # Set connection&#39;s end point.
        self.newConnection.target_point = self.mapToScene(event.pos())
        self.newConnection.updatePath()
    else:
        super(pyqtSlotItem, self).mouseMoveEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the connection process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    &#34;&#34;&#34;
    Start the connection process.

    &#34;&#34;&#34;
    if event.button() == QtCore.Qt.LeftButton:
        self.newConnection = ConnectionItem(self.center(),
                                            self.mapToScene(event.pos()),
                                            self,
                                            None)

        self.connections.append(self.newConnection)
        self.scene().addItem(self.newConnection)

        nodzInst = self.scene().views()[0]
        nodzInst.drawingConnection = True
        nodzInst.sourcepyqtSlot = self
        nodzInst.currentDataType = self.dataType
    else:
        super(pyqtSlotItem, self).mousePressEvent(event)</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the connection if target_pyqtSlot is valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, event):
    &#34;&#34;&#34;
    Apply the connection if target_pyqtSlot is valid.

    &#34;&#34;&#34;
    nodzInst = self.scene().views()[0]
    if event.button() == QtCore.Qt.LeftButton:
        nodzInst.drawingConnection = False
        nodzInst.currentDataType = None

        target = self.scene().itemAt(event.scenePos().toPoint(), QtGui.QTransform())

        if not isinstance(target, pyqtSlotItem):
            self.newConnection._remove()
            super(pyqtSlotItem, self).mouseReleaseEvent(event)
            return

        if target.accepts(self):
            self.newConnection.target = target
            self.newConnection.source = self
            self.newConnection.target_point = target.center()
            self.newConnection.source_point = self.center()

            # Perform the ConnectionItem.
            self.connect(target, self.newConnection)
            target.connect(self, self.newConnection)

            self.newConnection.updatePath()
        else:
            self.newConnection._remove()
    else:
        super(pyqtSlotItem, self).mouseReleaseEvent(event)

    nodzInst.currentHoveredNode = None</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint"><code class="name flex">
<span>def <span class="ident">paint</span></span>(<span>self, painter, option, widget)</span>
</code></dt>
<dd>
<div class="desc"><p>Paint the pyqtSlot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint(self, painter, option, widget):
    &#34;&#34;&#34;
    Paint the pyqtSlot.

    &#34;&#34;&#34;
    painter.setBrush(self.brush)
    painter.setPen(self.pen)

    nodzInst = self.scene().views()[0]
    config = nodzInst.config
    if nodzInst.drawingConnection:
        if self.parentItem() == nodzInst.currentHoveredNode:
            painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
            if (self.pyqtSlotType == nodzInst.sourcepyqtSlot.pyqtSlotType or (self.pyqtSlotType != nodzInst.sourcepyqtSlot.pyqtSlotType and self.dataType != nodzInst.sourcepyqtSlot.dataType)):
                painter.setBrush(utils._convertDataToColor(config[&#39;non_connectable_color&#39;]))
            else:
                _penValid = QtGui.QPen()
                _penValid.setStyle(QtCore.Qt.SolidLine)
                _penValid.setWidth(2)
                _penValid.setColor(QtGui.QColor(255, 255, 255, 255))
                painter.setPen(_penValid)
                painter.setBrush(self.brush)

    painter.drawEllipse(self.boundingRect())</code></pre>
</details>
</dd>
<dt id="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The shape of the pyqtSlot is a circle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape(self):
    &#34;&#34;&#34;
    The shape of the pyqtSlot is a circle.

    &#34;&#34;&#34;
    path = QtGui.QPainterPath()
    path.addRect(self.boundingRect())
    return path</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="WizualizacjaAlgorytmow.NodZ" href="index.html">WizualizacjaAlgorytmow.NodZ</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem" href="#WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem">ConnectionItem</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.updatePath" href="#WizualizacjaAlgorytmow.NodZ.Main.ConnectionItem.updatePath">updatePath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem">NodeItem</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.boundingRect" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.boundingRect">boundingRect</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.height" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.height">height</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.hoverLeaveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.hoverLeaveEvent">hoverLeaveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseDoubleClickEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseDoubleClickEvent">mouseDoubleClickEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.paint" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.paint">paint</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.pen" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.pen">pen</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeItem.shape" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeItem.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene">NodeScene</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragEnterEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragEnterEvent">dragEnterEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dragMoveEvent">dragMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.drawBackground" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.drawBackground">drawBackground</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dropEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.dropEvent">dropEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.pyqtSignal_NodeMoved" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.pyqtSignal_NodeMoved">pyqtSignal_NodeMoved</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.NodeScene.updateScene" href="#WizualizacjaAlgorytmow.NodZ.Main.NodeScene.updateScene">updateScene</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz">Nodz</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.clearGraph" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.clearGraph">clearGraph</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createAttribute" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.createAttribute">createAttribute</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createConnection" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.createConnection">createConnection</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.createNode" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.createNode">createNode</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteAttribute" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteAttribute">deleteAttribute</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteNode" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.deleteNode">deleteNode</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.editAttribute" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.editAttribute">editAttribute</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.editNode" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.editNode">editNode</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.evaluateGraph" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.evaluateGraph">evaluateGraph</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.initialize" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.initialize">initialize</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyPressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyPressEvent">keyPressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.keyReleaseEvent">keyReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadConfig" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadConfig">loadConfig</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadGraph" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.loadGraph">loadGraph</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrCreated" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrCreated">pyqtSignal_AttrCreated</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrDeleted" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrDeleted">pyqtSignal_AttrDeleted</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrEdited" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_AttrEdited">pyqtSignal_AttrEdited</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_Dropped" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_Dropped">pyqtSignal_Dropped</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphCleared" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphCleared">pyqtSignal_GraphCleared</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphEvaluated" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphEvaluated">pyqtSignal_GraphEvaluated</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphLoaded" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphLoaded">pyqtSignal_GraphLoaded</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphSaved" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_GraphSaved">pyqtSignal_GraphSaved</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_KeyPressed" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_KeyPressed">pyqtSignal_KeyPressed</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeCreated" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeCreated">pyqtSignal_NodeCreated</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDeleted" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDeleted">pyqtSignal_NodeDeleted</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDoubleClicked" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeDoubleClicked">pyqtSignal_NodeDoubleClicked</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeEdited" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeEdited">pyqtSignal_NodeEdited</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeMoved" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeMoved">pyqtSignal_NodeMoved</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeSelected" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_NodeSelected">pyqtSignal_NodeSelected</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugConnected" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugConnected">pyqtSignal_PlugConnected</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugDisconnected" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_PlugDisconnected">pyqtSignal_PlugDisconnected</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketConnected" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketConnected">pyqtSignal_SocketConnected</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketDisconnected" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.pyqtSignal_SocketDisconnected">pyqtSignal_SocketDisconnected</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.saveGraph" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.saveGraph">saveGraph</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.Nodz.wheelEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.Nodz.wheelEvent">wheelEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.PlugItem" href="#WizualizacjaAlgorytmow.NodZ.Main.PlugItem">PlugItem</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.boundingRect" href="#WizualizacjaAlgorytmow.NodZ.Main.PlugItem.boundingRect">boundingRect</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.connect" href="#WizualizacjaAlgorytmow.NodZ.Main.PlugItem.connect">connect</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.PlugItem.disconnect" href="#WizualizacjaAlgorytmow.NodZ.Main.PlugItem.disconnect">disconnect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.SocketItem" href="#WizualizacjaAlgorytmow.NodZ.Main.SocketItem">SocketItem</a></code></h4>
<ul class="">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.boundingRect" href="#WizualizacjaAlgorytmow.NodZ.Main.SocketItem.boundingRect">boundingRect</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.connect" href="#WizualizacjaAlgorytmow.NodZ.Main.SocketItem.connect">connect</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.SocketItem.disconnect" href="#WizualizacjaAlgorytmow.NodZ.Main.SocketItem.disconnect">disconnect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem">pyqtSlotItem</a></code></h4>
<ul class="two-column">
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.accepts">accepts</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.center">center</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.paint">paint</a></code></li>
<li><code><a title="WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape" href="#WizualizacjaAlgorytmow.NodZ.Main.pyqtSlotItem.shape">shape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>